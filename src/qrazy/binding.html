---
layout: base.njk
title: Binding - qrazy - qry.zone
description: How do you connect JavaScript state to the DOM? Walking the tree, parsing attributes, and evaluating expressions.
---

<link rel="stylesheet" href="/assets/css/prism-zenburn.css">

<style>
.breadcrumb {
    font-size: 0.85rem;
    color: var(--color-text-secondary);
    margin-bottom: var(--space-md);
}
.breadcrumb a {
    color: var(--color-text-secondary);
}
.breadcrumb a:hover {
    color: var(--color-accent);
}
.philosophy-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: var(--space-md);
    margin: var(--space-lg) 0;
}
@media (max-width: 600px) {
    .philosophy-grid {
        grid-template-columns: 1fr;
    }
}
.philosophy-card {
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: var(--border-radius);
    padding: var(--space-md);
}
.philosophy-card h4 {
    margin: 0 0 var(--space-sm) 0;
    color: var(--color-accent);
}
.philosophy-card .frameworks {
    font-size: 0.8rem;
    color: var(--color-text-secondary);
    font-family: var(--font-mono);
}
.callout {
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-left: 3px solid var(--color-accent);
    padding: var(--space-md);
    margin: var(--space-lg) 0;
    font-size: 0.95rem;
}
.callout.warning {
    border-left-color: #f0ad4e;
}
.demo-container {
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: var(--border-radius);
    padding: var(--space-lg);
    margin: var(--space-lg) 0;
}
.demo-container h4 {
    margin-top: 0;
    color: var(--color-accent);
    font-size: 0.9rem;
}
.step-list {
    counter-reset: step;
    list-style: none;
    padding: 0;
}
.step-list li {
    counter-increment: step;
    padding-left: var(--space-xl);
    position: relative;
    margin-bottom: var(--space-md);
}
.step-list li::before {
    content: counter(step);
    position: absolute;
    left: 0;
    width: 1.5rem;
    height: 1.5rem;
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: 50%;
    text-align: center;
    line-height: 1.5rem;
    font-size: 0.8rem;
    font-family: var(--font-mono);
    color: var(--color-accent);
}
.nav-footer {
    display: flex;
    justify-content: space-between;
    margin-top: var(--space-xxl);
    padding-top: var(--space-lg);
    border-top: 1px solid var(--color-border);
}
.nav-footer a {
    color: var(--color-text-secondary);
    font-size: 0.9rem;
}
.nav-footer a:hover {
    color: var(--color-accent);
}
</style>

<article class="article">
    <div class="breadcrumb">
        <a href="/qrazy/">qrazy</a> / binding
    </div>

    <header class="article-header">
        <h1>Binding</h1>
        <p class="article-subtitle">How do you connect state to the DOM?</p>
    </header>

    <section>
        <h2>The problem</h2>
        <p>
            HTML doesn't know about your JavaScript objects. When you write <code>&lt;span&gt;{{ count }}&lt;/span&gt;</code>, the browser just sees the literal text "{{ count }}".
        </p>
        <p>
            Something has to find that placeholder, figure out what <code>count</code> refers to, and replace it with the actual value. That something is the binding system.
        </p>
    </section>

    <section>
        <h2>Two philosophies</h2>

        <div class="philosophy-grid">
            <div class="philosophy-card">
                <h4>Compile-time</h4>
                <p>Transform the template before it runs. Turn <code>&lt;span&gt;{count}&lt;/span&gt;</code> into <code>createElement('span', count)</code> during the build step.</p>
                <div class="frameworks">React JSX, Svelte, Vue SFC</div>
            </div>
            <div class="philosophy-card">
                <h4>Runtime</h4>
                <p>Parse the DOM at load time. Find special attributes, wire them up to state on the fly. No build step needed.</p>
                <div class="frameworks">Alpine, htmx, qrazy</div>
            </div>
        </div>

        <p>
            Compile-time is faster (less work at runtime). Runtime is simpler (no tooling required). qrazy uses runtime binding because we're optimizing for understanding, not performance.
        </p>
    </section>

    <section>
        <h2>qrazy's approach</h2>
        <p>
            Four steps:
        </p>

        <ol class="step-list">
            <li>
                <strong>Find scopes:</strong> <code>querySelectorAll('[q-data]')</code> returns every element that defines reactive state.
            </li>
            <li>
                <strong>Parse state:</strong> Take the attribute value <code>"{ count: 0 }"</code> and turn it into an actual object using <code>new Function()</code>.
            </li>
            <li>
                <strong>Walk the tree:</strong> Use <code>TreeWalker</code> to visit every descendant element, looking for <code>q-text</code>, <code>q-click</code>, etc.
            </li>
            <li>
                <strong>Bind:</strong> For each directive found, create an updater function and store it on the element.
            </li>
        </ol>
    </section>

    <section>
        <h2>The TreeWalker API</h2>
        <p>
            You could use <code>querySelectorAll('*')</code> to get all descendants, but <code>TreeWalker</code> is more efficient and gives you control over the traversal.
        </p>

        <pre><code class="language-javascript">const walker = document.createTreeWalker(
  root,                        // starting element
  NodeFilter.SHOW_ELEMENT      // only visit elements (not text nodes)
);

while (walker.nextNode()) {
  const node = walker.currentNode;
  // Check for q-* attributes
  if (node.hasAttribute('q-text')) {
    bindText(node, state);
  }
}</code></pre>

        <p>
            qrazy uses this to walk each <code>q-data</code> scope, collecting all bindable elements. We also skip nested <code>q-data</code> scopes—they get their own state.
        </p>
    </section>

    <section>
        <h2>Expression evaluation</h2>
        <p>
            When you write <code>q-text="count + 1"</code>, qrazy needs to evaluate that expression in the context of the state object. The trick: <code>new Function()</code>.
        </p>

        <pre><code class="language-javascript">function evaluate(expr, state) {
  const keys = Object.keys(state);   // ['count', 'name', ...]
  const vals = Object.values(state); // [0, 'Alice', ...]

  // Build: new Function('count', 'name', 'return count + 1')
  return new Function(...keys, `return ${expr}`)(...vals);
}

// Example:
evaluate('count + 1', { count: 5 });  // → 6
evaluate('name.toUpperCase()', { name: 'alice' });  // → 'ALICE'</code></pre>

        <p>
            This is how Alpine does it too. You're essentially creating a tiny function whose parameters are the state keys, then calling it with the state values.
        </p>

        <div class="callout warning">
            <strong>Security note:</strong> This uses <code>eval</code>-like behavior. It's safe here because the expressions come from your own HTML—same-origin code. Never evaluate user-provided strings this way.
        </div>
    </section>

    <section>
        <h2>The scope chain</h2>
        <p>
            What if you have nested <code>q-data</code> scopes?
        </p>

        <pre><code class="language-html">&lt;div q-data="{ theme: 'dark' }"&gt;
  &lt;div q-data="{ count: 0 }"&gt;
    &lt;!-- Can this access theme? --&gt;
    &lt;span q-text="theme"&gt;&lt;/span&gt;
  &lt;/div&gt;
&lt;/div&gt;</code></pre>

        <p>
            In qrazy's current design: <strong>no</strong>. Each <code>q-data</code> scope is independent. The inner div only sees <code>count</code>, not <code>theme</code>.
        </p>
        <p>
            This is a simplification. Alpine supports scope inheritance. Vue has provide/inject. For qrazy, we kept it simple—one scope, one state object.
        </p>
    </section>

    <section>
        <h2>Storing updaters</h2>
        <p>
            When state changes, we need to update the DOM. But we don't want to re-walk the entire tree every time. Solution: store updater functions on the elements themselves.
        </p>

        <pre><code class="language-javascript">if (el.hasAttribute('q-text')) {
  const expr = el.getAttribute('q-text');

  // Create an updater function
  const update = () => {
    el.textContent = evaluate(expr, state);
  };

  // Run it once (initial render)
  update();

  // Store it for later
  el._qUpdaters = el._qUpdaters || [];
  el._qUpdaters.push(update);
}</code></pre>

        <p>
            Now when state changes, we just loop through elements and call their stored updaters:
        </p>

        <pre><code class="language-javascript">const state = reactive(data, () => {
  for (const el of elements) {
    if (el._qUpdaters) {
      el._qUpdaters.forEach(fn => fn());
    }
  }
});</code></pre>

        <p>
            This is "coarse-grained" reactivity—any change triggers all updaters. Fine-grained systems (like Solid) track dependencies per-expression so they only run affected updaters.
        </p>
    </section>

    <section>
        <h2>Interactive demo</h2>
        <p>
            Watch the binding system connect state to DOM:
        </p>

        <div class="demo-container">
            <h4>Try it: Live binding</h4>
            <div q-data="{ message: 'Hello', uppercase: false }">
                <p>
                    <input type="text" q-model="message" placeholder="Type something..." style="padding: 0.5rem; width: 100%; box-sizing: border-box; background: #2d2d2d; border: 1px solid var(--color-border); color: var(--color-text-primary); border-radius: var(--border-radius);">
                </p>
                <p>
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                        <input type="checkbox" q-click="uppercase = !uppercase">
                        Uppercase
                    </label>
                </p>
                <p style="font-size: 1.5rem; font-family: var(--font-mono);">
                    <span q-show="!uppercase" q-text="message"></span>
                    <span q-show="uppercase" q-text="message.toUpperCase()"></span>
                </p>
            </div>
        </div>

        <p style="font-size: 0.85rem; color: var(--color-text-secondary);">
            The input uses <code>q-model</code> for two-way binding. The output uses <code>q-text</code> with an expression. The checkbox uses <code>q-click</code> to toggle state.
        </p>
    </section>

    <section>
        <h2>First principles</h2>
        <p>
            What <em>is</em> a binding? It's a contract: "when this state changes, update that DOM node." The binding system is just a registry of these contracts.
        </p>
        <p>
            Some frameworks make bindings implicit (React's re-render). Others make them explicit (qrazy's attributes). Either way, you're mapping state → DOM.
        </p>
        <p>
            The key insight: the DOM and your state are two representations of the same truth. Binding keeps them synchronized.
        </p>
    </section>

    <nav class="nav-footer">
        <a href="/qrazy/reactivity/">← Reactivity</a>
        <a href="/qrazy/reconciliation/">Next: Reconciliation →</a>
    </nav>
</article>

<script src="/assets/js/qrazy.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup.min.js"></script>
