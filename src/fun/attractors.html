---
layout: false
permalink: /fun/attractors/
---
<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="description" content="Strange attractor visualizations - Lorenz, Rössler, and more" />
        <title>Strange Attractors</title>

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="/assets/css/fun-pages.css">

        <style>
            :root {
                --bg-deep: #050508;
                --bg-surface: #0a0a10;
                --bg-elevated: #12121a;
                --accent: #00ff88;
                --accent-rgb: 0, 255, 136;
                --accent-dim: rgba(0, 255, 136, 0.3);
                --accent-glow: rgba(0, 255, 136, 0.15);
                --border: #1a1a2a;
            }

            body.fullscreen .top-btn { background: rgba(5, 5, 8, 0.8); }

            #canvas {
                cursor: grab;
                touch-action: none;
            }

            #canvas:active { cursor: grabbing; }

            .slider-control input[type="range"] { width: 80px; }
            .slider-label { min-width: 50px; }

            .presets-label {
                font-size: 0.75rem;
                color: var(--text-secondary);
            }

            .modal code {
                background: var(--bg-elevated);
                padding: 0.1rem 0.3rem;
                border-radius: 3px;
                color: var(--accent);
            }
        </style>
    </head>
    <body>
        <a href="/fun/" class="back-link">← back</a>
        <button class="top-btn fullscreen-btn" id="fullscreenBtn" title="Fullscreen (F)">⛶</button>
        <button class="top-btn help-btn" id="helpBtn" title="Help (?)">?</button>

        <header class="game-header">
            <h1 class="game-title">Strange Attractors</h1>
            <div class="stats-bar">
                <div class="stat">
                    <span class="stat-label">Points:</span>
                    <span class="stat-value" id="pointCount">0</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Attractor:</span>
                    <span class="stat-value" id="attractorName">Lorenz</span>
                </div>
                <div class="stat">
                    <span class="stat-label" id="statusLabel">Running</span>
                </div>
            </div>
        </header>

        <div class="canvas-container">
            <canvas id="canvas"></canvas>
        </div>

        <div class="controls">
            <div class="control-row">
                <button class="primary" id="playPauseBtn">Pause</button>
                <button id="resetBtn">Reset</button>
                <button id="autoRotateBtn" class="active">Auto-Rotate</button>
            </div>
            <div class="control-row">
                <span class="presets-label">Attractor:</span>
                <button data-attractor="lorenz" class="active">Lorenz</button>
                <button data-attractor="rossler">Rössler</button>
                <button data-attractor="halvorsen">Halvorsen</button>
                <button data-attractor="aizawa">Aizawa</button>
                <button data-attractor="thomas">Thomas</button>
            </div>
            <div class="control-row">
                <div class="slider-control">
                    <span class="slider-label">Speed:</span>
                    <input type="range" id="speedSlider" min="1" max="20" value="5">
                </div>
                <div class="slider-control">
                    <span class="slider-label">Trails:</span>
                    <input type="range" id="trailSlider" min="500" max="10000" value="5000">
                </div>
                <div class="slider-control">
                    <span class="slider-label">Zoom:</span>
                    <input type="range" id="zoomSlider" min="5" max="30" value="12">
                </div>
            </div>
        </div>

        <!-- Help Modal -->
        <div class="modal-overlay" id="helpModal">
            <div class="modal">
                <h2>Strange Attractors</h2>
                <p>Visualizations of <a href="https://en.wikipedia.org/wiki/Attractor#Strange_attractor" target="_blank" style="color: var(--accent)">chaotic dynamical systems</a>. These mathematical systems never repeat exactly, yet stay bounded in beautiful patterns.</p>
                <p><strong>Attractors:</strong></p>
                <ul>
                    <li><a href="https://en.wikipedia.org/wiki/Lorenz_system" target="_blank" style="color: var(--accent)">Lorenz</a> - The famous "butterfly" attractor (weather model)</li>
                    <li><a href="https://en.wikipedia.org/wiki/R%C3%B6ssler_attractor" target="_blank" style="color: var(--accent)">Rössler</a> - Simple spiral chaos</li>
                    <li><a href="https://en.wikipedia.org/wiki/Halvorsen_attractor" target="_blank" style="color: var(--accent)">Halvorsen</a> - Three-lobed symmetry</li>
                    <li>Aizawa - Nested torus structure</li>
                    <li><a href="https://en.wikipedia.org/wiki/Thomas%27_cyclically_symmetric_attractor" target="_blank" style="color: var(--accent)">Thomas</a> - Cyclically symmetric attractor</li>
                </ul>
                <p><strong>Controls:</strong></p>
                <ul>
                    <li><strong>Drag</strong> - Rotate view manually</li>
                    <li><strong>Auto-Rotate</strong> - Toggle automatic rotation</li>
                    <li><strong>Trails</strong> - How many points to draw</li>
                    <li><strong>Zoom</strong> - Scale the visualization</li>
                </ul>
                <p><strong>Keyboard:</strong></p>
                <ul>
                    <li><strong>Space</strong> - Play/Pause</li>
                    <li><strong>R</strong> - Reset</li>
                    <li><strong>A</strong> - Toggle auto-rotate</li>
                    <li><strong>1-5</strong> - Switch attractors</li>
                    <li><strong>F</strong> - Fullscreen</li>
                </ul>
                <button class="modal-close" id="closeHelp">Got it</button>
            </div>
        </div>

        <script>
            // Attractor definitions
            const ATTRACTORS = {
                lorenz: {
                    name: 'Lorenz',
                    params: { sigma: 10, rho: 28, beta: 8/3 },
                    dt: 0.005,
                    scale: 12,
                    step: (x, y, z, p) => ({
                        dx: p.sigma * (y - x),
                        dy: x * (p.rho - z) - y,
                        dz: x * y - p.beta * z
                    }),
                    init: () => ({ x: 1, y: 1, z: 1 })
                },
                rossler: {
                    name: 'Rössler',
                    params: { a: 0.2, b: 0.2, c: 5.7 },
                    dt: 0.02,
                    scale: 18,
                    step: (x, y, z, p) => ({
                        dx: -y - z,
                        dy: x + p.a * y,
                        dz: p.b + z * (x - p.c)
                    }),
                    init: () => ({ x: 0.1, y: 0, z: 0 })
                },
                halvorsen: {
                    name: 'Halvorsen',
                    params: { a: 1.89 },
                    dt: 0.005,
                    scale: 25,
                    step: (x, y, z, p) => ({
                        dx: -p.a * x - 4 * y - 4 * z - y * y,
                        dy: -p.a * y - 4 * z - 4 * x - z * z,
                        dz: -p.a * z - 4 * x - 4 * y - x * x
                    }),
                    init: () => ({ x: -5, y: 0, z: 0 })
                },
                aizawa: {
                    name: 'Aizawa',
                    params: { a: 0.95, b: 0.7, c: 0.6, d: 3.5, e: 0.25, f: 0.1 },
                    dt: 0.01,
                    scale: 180,
                    step: (x, y, z, p) => ({
                        dx: (z - p.b) * x - p.d * y,
                        dy: p.d * x + (z - p.b) * y,
                        dz: p.c + p.a * z - (z * z * z) / 3 - (x * x + y * y) * (1 + p.e * z) + p.f * z * x * x * x
                    }),
                    init: () => ({ x: 0.1, y: 0, z: 0 })
                },
                thomas: {
                    name: 'Thomas',
                    params: { b: 0.208186 },
                    dt: 0.05,
                    scale: 100,
                    step: (x, y, z, p) => ({
                        dx: Math.sin(y) - p.b * x,
                        dy: Math.sin(z) - p.b * y,
                        dz: Math.sin(x) - p.b * z
                    }),
                    init: () => ({ x: 1.1, y: 1.1, z: -0.01 })
                }
            };

            // State
            let currentAttractor = 'lorenz';
            let points = [];
            let running = true;
            let autoRotate = true;
            let rotationX = 0.3;
            let rotationY = 0;
            let rotationZ = 0;
            let speed = 5;
            let maxPoints = 5000;
            let zoom = 12;
            let state = { x: 1, y: 1, z: 1 };

            // Canvas
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');

            // Dragging
            let isDragging = false;
            let lastX = 0, lastY = 0;

            // Initialize
            function init() {
                const container = document.querySelector('.canvas-container');
                const maxWidth = container.clientWidth - 20;
                const maxHeight = container.clientHeight - 20;
                const size = Math.min(maxWidth, maxHeight, 700);

                canvas.width = size;
                canvas.height = size;

                reset();
            }

            // Reset
            function reset() {
                const attractor = ATTRACTORS[currentAttractor];
                state = attractor.init();
                points = [];
                document.getElementById('attractorName').textContent = attractor.name;
                updateStats();
            }

            // Step the attractor
            function step() {
                const attractor = ATTRACTORS[currentAttractor];
                const { dx, dy, dz } = attractor.step(state.x, state.y, state.z, attractor.params);

                state.x += dx * attractor.dt;
                state.y += dy * attractor.dt;
                state.z += dz * attractor.dt;

                points.push({ x: state.x, y: state.y, z: state.z });
                if (points.length > maxPoints) {
                    points.shift();
                }
            }

            // 3D rotation and projection
            function project(x, y, z) {
                // Rotate around X
                let y1 = y * Math.cos(rotationX) - z * Math.sin(rotationX);
                let z1 = y * Math.sin(rotationX) + z * Math.cos(rotationX);

                // Rotate around Y
                let x2 = x * Math.cos(rotationY) + z1 * Math.sin(rotationY);
                let z2 = -x * Math.sin(rotationY) + z1 * Math.cos(rotationY);

                // Rotate around Z
                let x3 = x2 * Math.cos(rotationZ) - y1 * Math.sin(rotationZ);
                let y3 = x2 * Math.sin(rotationZ) + y1 * Math.cos(rotationZ);

                // Project to 2D
                const scale = zoom;
                return {
                    x: canvas.width / 2 + x3 * scale,
                    y: canvas.height / 2 + y3 * scale,
                    z: z2
                };
            }

            // Draw
            function draw() {
                ctx.fillStyle = 'rgba(5, 5, 8, 0.15)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                if (points.length < 2) return;

                // Draw trail with depth coloring
                for (let i = 1; i < points.length; i++) {
                    const p1 = project(points[i-1].x, points[i-1].y, points[i-1].z);
                    const p2 = project(points[i].x, points[i].y, points[i].z);

                    const age = i / points.length;
                    const hue = 120 + (points[i].z * 3) % 60; // Green to teal based on z
                    const alpha = age * 0.8;

                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.strokeStyle = `hsla(${hue}, 100%, 50%, ${alpha})`;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }

                // Draw current point
                if (points.length > 0) {
                    const last = points[points.length - 1];
                    const p = project(last.x, last.y, last.z);
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                    ctx.fillStyle = '#00ff88';
                    ctx.fill();
                }
            }

            // Update stats
            function updateStats() {
                document.getElementById('pointCount').textContent = points.length.toLocaleString();
                document.getElementById('statusLabel').textContent = running ? 'Running' : 'Paused';
            }

            // Animation loop
            function animate() {
                if (running) {
                    for (let i = 0; i < speed; i++) {
                        step();
                    }
                    if (autoRotate) {
                        rotationY += 0.003;
                    }
                    draw();
                    updateStats();
                }
                requestAnimationFrame(animate);
            }

            // Controls
            const playPauseBtn = document.getElementById('playPauseBtn');
            playPauseBtn.addEventListener('click', () => {
                running = !running;
                playPauseBtn.textContent = running ? 'Pause' : 'Play';
                updateStats();
            });

            document.getElementById('resetBtn').addEventListener('click', reset);

            const autoRotateBtn = document.getElementById('autoRotateBtn');
            autoRotateBtn.addEventListener('click', () => {
                autoRotate = !autoRotate;
                autoRotateBtn.classList.toggle('active', autoRotate);
            });

            // Attractor buttons
            document.querySelectorAll('[data-attractor]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('[data-attractor]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentAttractor = btn.dataset.attractor;
                    zoom = ATTRACTORS[currentAttractor].scale;
                    document.getElementById('zoomSlider').value = zoom;
                    reset();
                });
            });

            // Sliders
            document.getElementById('speedSlider').addEventListener('input', (e) => {
                speed = parseInt(e.target.value);
            });

            document.getElementById('trailSlider').addEventListener('input', (e) => {
                maxPoints = parseInt(e.target.value);
            });

            document.getElementById('zoomSlider').addEventListener('input', (e) => {
                zoom = parseInt(e.target.value);
            });

            // Mouse drag rotation
            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                lastX = e.clientX;
                lastY = e.clientY;
                autoRotate = false;
                autoRotateBtn.classList.remove('active');
            });

            canvas.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const dx = e.clientX - lastX;
                const dy = e.clientY - lastY;
                rotationY += dx * 0.01;
                rotationX += dy * 0.01;
                lastX = e.clientX;
                lastY = e.clientY;
            });

            canvas.addEventListener('mouseup', () => isDragging = false);
            canvas.addEventListener('mouseleave', () => isDragging = false);

            // Touch support
            canvas.addEventListener('touchstart', (e) => {
                isDragging = true;
                lastX = e.touches[0].clientX;
                lastY = e.touches[0].clientY;
                autoRotate = false;
                autoRotateBtn.classList.remove('active');
            });

            canvas.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                e.preventDefault();
                const dx = e.touches[0].clientX - lastX;
                const dy = e.touches[0].clientY - lastY;
                rotationY += dx * 0.01;
                rotationX += dy * 0.01;
                lastX = e.touches[0].clientX;
                lastY = e.touches[0].clientY;
            });

            canvas.addEventListener('touchend', () => isDragging = false);

            // Help modal
            const helpModal = document.getElementById('helpModal');
            document.getElementById('helpBtn').addEventListener('click', () => {
                helpModal.classList.add('show');
            });
            document.getElementById('closeHelp').addEventListener('click', () => {
                helpModal.classList.remove('show');
            });
            helpModal.addEventListener('click', (e) => {
                if (e.target === helpModal) helpModal.classList.remove('show');
            });

            // Fullscreen
            let isFullscreen = false;
            const fullscreenBtn = document.getElementById('fullscreenBtn');

            function toggleFullscreen() {
                isFullscreen = !isFullscreen;
                document.body.classList.toggle('fullscreen', isFullscreen);
                fullscreenBtn.title = isFullscreen ? 'Exit Fullscreen (Esc)' : 'Fullscreen (F)';
                setTimeout(init, 50);
            }

            fullscreenBtn.addEventListener('click', toggleFullscreen);

            // Keyboard shortcuts
            const attractorKeys = ['lorenz', 'rossler', 'halvorsen', 'aizawa', 'thomas'];
            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT') return;

                switch(e.key.toLowerCase()) {
                    case 'f':
                        toggleFullscreen();
                        break;
                    case 'escape':
                        if (isFullscreen) toggleFullscreen();
                        if (helpModal.classList.contains('show')) helpModal.classList.remove('show');
                        break;
                    case ' ':
                        e.preventDefault();
                        running = !running;
                        playPauseBtn.textContent = running ? 'Pause' : 'Play';
                        updateStats();
                        break;
                    case 'r':
                        reset();
                        break;
                    case 'a':
                        autoRotate = !autoRotate;
                        autoRotateBtn.classList.toggle('active', autoRotate);
                        break;
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                        const idx = parseInt(e.key) - 1;
                        if (attractorKeys[idx]) {
                            document.querySelectorAll('[data-attractor]').forEach(b => b.classList.remove('active'));
                            document.querySelector(`[data-attractor="${attractorKeys[idx]}"]`).classList.add('active');
                            currentAttractor = attractorKeys[idx];
                            zoom = ATTRACTORS[currentAttractor].scale;
                            document.getElementById('zoomSlider').value = zoom;
                            reset();
                        }
                        break;
                }
            });

            // Resize
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(init, 250);
            });

            // Start
            init();
            requestAnimationFrame(animate);
        </script>
    </body>
</html>
