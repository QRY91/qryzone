---
layout: false
permalink: /fun/maze/
---
<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="description" content="Interactive maze generation and pathfinding algorithm visualizer" />
        <title>Maze Solver</title>

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            :root {
                --bg-deep: #0a0a12;
                --bg-surface: #10101a;
                --bg-elevated: #181824;
                --accent: #9d4edd;
                --accent-dim: rgba(157, 78, 221, 0.3);
                --accent-glow: rgba(157, 78, 221, 0.15);
                --text-primary: #e0e0e0;
                --text-secondary: #7a7a8a;
                --border: #2a2a3a;
                --wall: #1a1a2e;
                --path: #0f0f1a;
                --visited: rgba(157, 78, 221, 0.3);
                --current: #ff6b6b;
                --solution: #4edd9d;
                --start: #4ecdc4;
                --end: #ff6b6b;
                --error: #ff6b6b;
                --success: #4edd9d;
            }

            body {
                font-family: 'JetBrains Mono', monospace;
                background: var(--bg-deep);
                color: var(--text-primary);
                min-height: 100vh;
                display: flex;
                flex-direction: column;
            }

            .back-link {
                position: fixed;
                top: 1rem;
                left: 1rem;
                background: var(--bg-elevated);
                border: 1px solid var(--border);
                padding: 0.5rem 1rem;
                border-radius: 4px;
                color: var(--accent);
                text-decoration: none;
                font-size: 0.85rem;
                z-index: 100;
                transition: all 0.2s ease;
            }

            .back-link:hover {
                border-color: var(--accent);
                box-shadow: 0 0 10px var(--accent-glow);
            }

            .top-btn {
                position: fixed;
                top: 1rem;
                background: var(--bg-elevated);
                border: 1px solid var(--border);
                width: 2.5rem;
                height: 2.5rem;
                border-radius: 4px;
                color: var(--accent);
                font-size: 1rem;
                cursor: pointer;
                z-index: 100;
                transition: all 0.2s ease;
            }

            .top-btn:hover {
                border-color: var(--accent);
                box-shadow: 0 0 10px var(--accent-glow);
            }

            .help-btn { right: 1rem; }
            .code-btn { right: 4rem; }

            .game-header {
                text-align: center;
                padding: 2rem 1rem 1rem;
                padding-top: 4rem;
            }

            .game-title {
                font-size: clamp(1.5rem, 5vw, 2rem);
                font-weight: 500;
                color: var(--accent);
                margin-bottom: 0.5rem;
                text-shadow: 0 0 20px var(--accent-glow);
            }

            .stats-bar {
                display: flex;
                justify-content: center;
                gap: 1.5rem;
                flex-wrap: wrap;
                font-size: 0.8rem;
                margin-bottom: 1rem;
            }

            .stat {
                display: flex;
                align-items: center;
                gap: 0.4rem;
            }

            .stat-label { color: var(--text-secondary); }
            .stat-value { color: var(--accent); font-size: 0.75rem; }

            .main-content {
                flex: 1;
                display: flex;
                gap: 1rem;
                padding: 0 1rem;
                min-height: 300px;
                position: relative;
                overflow: hidden;
            }

            .canvas-container {
                flex: 1;
                display: flex;
                justify-content: center;
                align-items: center;
                position: relative;
            }

            #canvas {
                border: 1px solid var(--border);
                max-width: 100%;
            }

            /* Code Editor Panel */
            .code-panel {
                position: absolute;
                right: 1rem;
                top: 0;
                height: 100%;
                width: 450px;
                z-index: 50;
                display: flex;
                flex-direction: column;
                background: var(--bg-surface);
                border: 1px solid var(--border);
                border-radius: 8px;
                transform: translateX(calc(100% + 2rem));
                transition: transform 0.3s ease;
            }

            .code-panel.open {
                transform: translateX(0);
            }

            .code-panel-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 0.75rem 1rem;
                border-bottom: 1px solid var(--border);
                background: var(--bg-elevated);
            }

            .code-panel-title {
                font-size: 0.85rem;
                color: var(--accent);
            }

            .code-panel-actions {
                display: flex;
                gap: 0.5rem;
            }

            .code-panel-actions button {
                padding: 0.3rem 0.6rem;
                font-size: 0.75rem;
            }

            .code-editor {
                flex: 1;
                display: flex;
                flex-direction: column;
                overflow: hidden;
            }

            .code-editor textarea {
                flex: 1;
                background: var(--bg-deep);
                border: none;
                color: var(--text-primary);
                font-family: 'JetBrains Mono', monospace;
                font-size: 0.75rem;
                line-height: 1.5;
                padding: 1rem;
                resize: none;
                outline: none;
                tab-size: 2;
            }

            .code-editor textarea::placeholder {
                color: var(--text-secondary);
            }

            .code-status {
                padding: 0.5rem 1rem;
                font-size: 0.7rem;
                border-top: 1px solid var(--border);
                background: var(--bg-elevated);
            }

            .code-status.error {
                color: var(--error);
            }

            .code-status.success {
                color: var(--success);
            }

            .controls {
                padding: 1rem;
                display: flex;
                flex-direction: column;
                gap: 0.75rem;
                max-width: 800px;
                margin: 0 auto;
            }

            .control-row {
                display: flex;
                justify-content: center;
                align-items: center;
                gap: 0.5rem;
                flex-wrap: wrap;
            }

            button {
                font-family: 'JetBrains Mono', monospace;
                background: var(--bg-elevated);
                border: 1px solid var(--accent-dim);
                color: var(--text-primary);
                padding: 0.5rem 1rem;
                border-radius: 4px;
                cursor: pointer;
                font-size: 0.85rem;
                transition: all 0.2s ease;
            }

            button:hover:not(:disabled) {
                border-color: var(--accent);
                background: var(--accent-glow);
            }

            button:disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }

            button.primary {
                background: var(--accent-glow);
                border-color: var(--accent);
                color: var(--accent);
            }

            button.active {
                background: var(--accent);
                color: var(--bg-deep);
                border-color: var(--accent);
            }

            .slider-control {
                display: flex;
                align-items: center;
                gap: 0.5rem;
            }

            .slider-control input[type="range"] {
                width: 80px;
                accent-color: var(--accent);
            }

            .slider-label {
                font-size: 0.75rem;
                color: var(--text-secondary);
                min-width: 50px;
            }

            .slider-value {
                font-size: 0.75rem;
                color: var(--accent);
                min-width: 35px;
            }

            .section-label {
                font-size: 0.75rem;
                color: var(--text-secondary);
            }

            /* Modal */
            .modal-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.85);
                display: none;
                justify-content: center;
                align-items: center;
                z-index: 200;
                padding: 1rem;
            }

            .modal-overlay.show { display: flex; }

            .modal {
                background: var(--bg-surface);
                border: 1px solid var(--border);
                border-radius: 8px;
                max-width: 550px;
                width: 100%;
                max-height: 80vh;
                overflow-y: auto;
                padding: 1.5rem;
            }

            .modal h2 {
                color: var(--accent);
                margin-bottom: 1rem;
                font-size: 1.25rem;
            }

            .modal h3 {
                color: var(--accent);
                margin: 1rem 0 0.5rem;
                font-size: 1rem;
            }

            .modal p, .modal ul {
                color: var(--text-secondary);
                line-height: 1.6;
                margin-bottom: 0.75rem;
                font-size: 0.9rem;
            }

            .modal ul { margin-left: 1.5rem; }
            .modal code {
                background: var(--bg-elevated);
                padding: 0.1rem 0.3rem;
                border-radius: 3px;
                color: var(--accent);
            }
            .modal-close { margin-top: 1rem; width: 100%; }

            .legend {
                display: flex;
                gap: 1rem;
                flex-wrap: wrap;
                justify-content: center;
                margin-top: 0.5rem;
            }

            .legend-item {
                display: flex;
                align-items: center;
                gap: 0.3rem;
                font-size: 0.7rem;
                color: var(--text-secondary);
            }

            .legend-color {
                width: 12px;
                height: 12px;
                border-radius: 2px;
            }

            @media (max-width: 900px) {
                .code-panel.open {
                    width: calc(100% - 2rem);
                    max-height: 50%;
                }
            }

            @media (max-width: 480px) {
                .control-row { gap: 0.4rem; }
                button { padding: 0.4rem 0.6rem; font-size: 0.75rem; }
                .slider-control input[type="range"] { width: 60px; }
            }
        </style>
    </head>
    <body>
        <a href="/fun/" class="back-link">&larr; back</a>
        <button class="top-btn code-btn" id="codeBtn" title="Code Editor">&lt;/&gt;</button>
        <button class="top-btn help-btn" id="helpBtn" title="Help (?)">?</button>

        <header class="game-header">
            <h1 class="game-title">Maze Solver</h1>
            <div class="stats-bar">
                <div class="stat">
                    <span class="stat-label">Size:</span>
                    <span class="stat-value" id="sizeDisplay">25x25</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Cells Visited:</span>
                    <span class="stat-value" id="visitedDisplay">0</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Path Length:</span>
                    <span class="stat-value" id="pathDisplay">-</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Status:</span>
                    <span class="stat-value" id="statusDisplay">Ready</span>
                </div>
            </div>
        </header>

        <div class="main-content">
            <div class="canvas-container">
                <canvas id="canvas"></canvas>
            </div>

            <div class="code-panel" id="codePanel">
                <div class="code-panel-header">
                    <span class="code-panel-title">Algorithm Editor</span>
                    <div class="code-panel-actions">
                        <button id="resetCodeBtn">Reset</button>
                        <button id="runCodeBtn" class="primary">Run</button>
                    </div>
                </div>
                <div class="code-editor">
                    <textarea id="codeEditor" spellcheck="false" placeholder="Select an algorithm to view and edit its code..."></textarea>
                </div>
                <div class="code-status" id="codeStatus">Ready to edit</div>
            </div>
        </div>

        <div class="controls">
            <div class="control-row">
                <button class="primary" id="generateBtn">Generate Maze</button>
                <button id="solveBtn">Solve</button>
                <button id="clearBtn">Clear Solution</button>
                <button id="stopBtn" disabled>Stop</button>
            </div>
            <div class="control-row">
                <span class="section-label">Generate:</span>
                <button data-gen="recursive" class="active">Recursive</button>
                <button data-gen="prims">Prim's</button>
                <button data-gen="kruskals">Kruskal's</button>
                <button data-gen="binary">Binary Tree</button>
            </div>
            <div class="control-row">
                <span class="section-label">Solve:</span>
                <button data-solve="astar" class="active">A*</button>
                <button data-solve="dijkstra">Dijkstra</button>
                <button data-solve="bfs">BFS</button>
                <button data-solve="dfs">DFS</button>
                <button data-solve="greedy">Greedy</button>
            </div>
            <div class="control-row">
                <div class="slider-control">
                    <span class="slider-label">Size:</span>
                    <input type="range" id="sizeSlider" min="11" max="61" step="2" value="25">
                    <span class="slider-value" id="sizeValue">25</span>
                </div>
                <div class="slider-control">
                    <span class="slider-label">Speed:</span>
                    <input type="range" id="speedSlider" min="1" max="100" value="50">
                    <span class="slider-value" id="speedValue">50</span>
                </div>
            </div>
            <div class="legend">
                <div class="legend-item"><div class="legend-color" style="background: var(--start);"></div> Start</div>
                <div class="legend-item"><div class="legend-color" style="background: var(--end);"></div> End</div>
                <div class="legend-item"><div class="legend-color" style="background: var(--visited);"></div> Visited</div>
                <div class="legend-item"><div class="legend-color" style="background: var(--current);"></div> Current</div>
                <div class="legend-item"><div class="legend-color" style="background: var(--solution);"></div> Solution</div>
            </div>
        </div>

        <!-- Help Modal -->
        <div class="modal-overlay" id="helpModal">
            <div class="modal">
                <h2>Maze Solver</h2>
                <p>Watch pathfinding algorithms navigate through procedurally generated mazes.</p>

                <h3>Generation Algorithms</h3>
                <ul>
                    <li><strong>Recursive Backtracker</strong> - DFS-based, creates long winding passages</li>
                    <li><strong>Prim's</strong> - Grows from random frontier cells, more branching</li>
                    <li><strong>Kruskal's</strong> - Union-find based, uniform distribution</li>
                    <li><strong>Binary Tree</strong> - Fast but biased toward corner</li>
                </ul>

                <h3>Solving Algorithms</h3>
                <ul>
                    <li><strong>A*</strong> - Optimal path using heuristic (Manhattan distance)</li>
                    <li><strong>Dijkstra</strong> - Optimal path, explores uniformly</li>
                    <li><strong>BFS</strong> - Guarantees shortest path in unweighted graphs</li>
                    <li><strong>DFS</strong> - Fast but may not find shortest path</li>
                    <li><strong>Greedy</strong> - Follows heuristic only, fast but suboptimal</li>
                </ul>

                <h3>Code Editor</h3>
                <p>Click the <code>&lt;/&gt;</code> button to open the code editor. You can modify algorithms and click "Run" to test your changes.</p>
                <p>Available helpers: <code>getNeighbors(pos)</code>, <code>heuristic(a, b)</code>, <code>visit(pos)</code>, <code>markSolution(path)</code></p>

                <h3>Controls</h3>
                <ul>
                    <li><strong>G</strong> - Generate new maze</li>
                    <li><strong>S</strong> - Start solving</li>
                    <li><strong>C</strong> - Clear solution</li>
                    <li><strong>E</strong> - Toggle code editor</li>
                    <li><strong>Escape</strong> - Stop animation</li>
                </ul>

                <button class="modal-close" id="closeHelp">Got it</button>
            </div>
        </div>

        <script>
            // Grid state
            const WALL = 0;
            const PATH = 1;
            const START = 2;
            const END = 3;
            const VISITED = 4;
            const CURRENT = 5;
            const SOLUTION = 6;

            let grid = [];
            let gridSize = 25;
            let cellSize = 0;
            let animationSpeed = 50;
            let isAnimating = false;
            let animationId = null;
            let startPos = { x: 1, y: 1 };
            let endPos = { x: 23, y: 23 };

            let genAlgorithm = 'recursive';
            let solveAlgorithm = 'astar';
            let useCustomCode = false;

            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const codeEditor = document.getElementById('codeEditor');
            const codeStatus = document.getElementById('codeStatus');

            // Colors
            const COLORS = {
                [WALL]: '#1a1a2e',
                [PATH]: '#0f0f1a',
                [START]: '#4ecdc4',
                [END]: '#ff6b6b',
                [VISITED]: 'rgba(157, 78, 221, 0.4)',
                [CURRENT]: '#ff6b6b',
                [SOLUTION]: '#4edd9d'
            };

            // Algorithm source code templates
            const SOLVE_ALGORITHMS = {
                astar: `// A* Algorithm - finds optimal path using heuristic
async function solve(ctx) {
  const openSet = [{ ...ctx.start, g: 0, f: ctx.heuristic(ctx.start, ctx.end) }];
  const cameFrom = {};
  const gScore = {};
  const key = p => p.x + ',' + p.y;
  gScore[key(ctx.start)] = 0;

  while (openSet.length > 0 && ctx.isRunning()) {
    openSet.sort((a, b) => a.f - b.f);
    const current = openSet.shift();

    if (current.x === ctx.end.x && current.y === ctx.end.y) {
      // Reconstruct path
      const path = [current];
      let node = current;
      while (cameFrom[key(node)]) {
        node = cameFrom[key(node)];
        path.unshift(node);
      }
      return path;
    }

    await ctx.visit(current);

    for (const neighbor of ctx.getNeighbors(current)) {
      const tentativeG = gScore[key(current)] + 1;
      if (tentativeG < (gScore[key(neighbor)] ?? Infinity)) {
        cameFrom[key(neighbor)] = current;
        gScore[key(neighbor)] = tentativeG;
        neighbor.g = tentativeG;
        neighbor.f = tentativeG + ctx.heuristic(neighbor, ctx.end);
        if (!openSet.some(n => n.x === neighbor.x && n.y === neighbor.y)) {
          openSet.push(neighbor);
        }
      }
    }
  }
  return null;
}`,

                dijkstra: `// Dijkstra's Algorithm - guaranteed shortest path
async function solve(ctx) {
  const dist = {};
  const prev = {};
  const queue = [];
  const key = p => p.x + ',' + p.y;

  dist[key(ctx.start)] = 0;
  queue.push({ ...ctx.start, d: 0 });

  while (queue.length > 0 && ctx.isRunning()) {
    queue.sort((a, b) => a.d - b.d);
    const current = queue.shift();

    if (current.x === ctx.end.x && current.y === ctx.end.y) {
      const path = [];
      let node = current;
      while (node) {
        path.unshift(node);
        node = prev[key(node)];
      }
      return path;
    }

    await ctx.visit(current);

    for (const neighbor of ctx.getNeighbors(current)) {
      const alt = dist[key(current)] + 1;
      if (alt < (dist[key(neighbor)] ?? Infinity)) {
        dist[key(neighbor)] = alt;
        prev[key(neighbor)] = current;
        queue.push({ ...neighbor, d: alt });
      }
    }
  }
  return null;
}`,

                bfs: `// Breadth-First Search - explores level by level
async function solve(ctx) {
  const queue = [{ ...ctx.start, path: [ctx.start] }];
  const visited = new Set();
  const key = p => p.x + ',' + p.y;
  visited.add(key(ctx.start));

  while (queue.length > 0 && ctx.isRunning()) {
    const current = queue.shift();

    if (current.x === ctx.end.x && current.y === ctx.end.y) {
      return current.path;
    }

    await ctx.visit(current);

    for (const neighbor of ctx.getNeighbors(current)) {
      const k = key(neighbor);
      if (!visited.has(k)) {
        visited.add(k);
        queue.push({
          ...neighbor,
          path: [...current.path, neighbor]
        });
      }
    }
  }
  return null;
}`,

                dfs: `// Depth-First Search - explores as deep as possible first
async function solve(ctx) {
  const stack = [{ ...ctx.start, path: [ctx.start] }];
  const visited = new Set();
  const key = p => p.x + ',' + p.y;

  while (stack.length > 0 && ctx.isRunning()) {
    const current = stack.pop();
    const k = key(current);

    if (visited.has(k)) continue;
    visited.add(k);

    if (current.x === ctx.end.x && current.y === ctx.end.y) {
      return current.path;
    }

    await ctx.visit(current);

    // Shuffle neighbors for variety
    const neighbors = ctx.getNeighbors(current);
    for (let i = neighbors.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [neighbors[i], neighbors[j]] = [neighbors[j], neighbors[i]];
    }

    for (const neighbor of neighbors) {
      if (!visited.has(key(neighbor))) {
        stack.push({
          ...neighbor,
          path: [...current.path, neighbor]
        });
      }
    }
  }
  return null;
}`,

                greedy: `// Greedy Best-First - follows heuristic only
async function solve(ctx) {
  const openSet = [{
    ...ctx.start,
    h: ctx.heuristic(ctx.start, ctx.end),
    path: [ctx.start]
  }];
  const visited = new Set();
  const key = p => p.x + ',' + p.y;

  while (openSet.length > 0 && ctx.isRunning()) {
    openSet.sort((a, b) => a.h - b.h);
    const current = openSet.shift();
    const k = key(current);

    if (visited.has(k)) continue;
    visited.add(k);

    if (current.x === ctx.end.x && current.y === ctx.end.y) {
      return current.path;
    }

    await ctx.visit(current);

    for (const neighbor of ctx.getNeighbors(current)) {
      if (!visited.has(key(neighbor))) {
        openSet.push({
          ...neighbor,
          h: ctx.heuristic(neighbor, ctx.end),
          path: [...current.path, neighbor]
        });
      }
    }
  }
  return null;
}`
            };

            // Store custom code for each algorithm
            const customCode = { ...SOLVE_ALGORITHMS };

            // Initialize
            function init() {
                const container = document.querySelector('.canvas-container');
                const maxSize = Math.min(container.clientWidth - 20, container.clientHeight - 20, 600);

                canvas.width = maxSize;
                canvas.height = maxSize;
                cellSize = Math.floor(maxSize / gridSize);

                generateMaze();
                updateCodeEditor();
            }

            // Draw grid
            function draw() {
                ctx.fillStyle = COLORS[WALL];
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                for (let y = 0; y < gridSize; y++) {
                    for (let x = 0; x < gridSize; x++) {
                        const cell = grid[y][x];
                        ctx.fillStyle = COLORS[cell];
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    }
                }
            }

            // Generate maze using selected algorithm
            function generateMaze() {
                stopAnimation();
                grid = Array(gridSize).fill(null).map(() => Array(gridSize).fill(WALL));

                switch (genAlgorithm) {
                    case 'recursive': generateRecursive(); break;
                    case 'prims': generatePrims(); break;
                    case 'kruskals': generateKruskals(); break;
                    case 'binary': generateBinaryTree(); break;
                }

                startPos = { x: 1, y: 1 };
                endPos = { x: gridSize - 2, y: gridSize - 2 };
                grid[startPos.y][startPos.x] = START;
                grid[endPos.y][endPos.x] = END;

                updateStats(0, '-');
                document.getElementById('statusDisplay').textContent = 'Ready';
                draw();
            }

            // Maze generation algorithms
            function generateRecursive() {
                const stack = [];
                const start = { x: 1, y: 1 };
                grid[start.y][start.x] = PATH;
                stack.push(start);

                while (stack.length > 0) {
                    const current = stack[stack.length - 1];
                    const neighbors = getUnvisitedNeighbors(current.x, current.y, 2);

                    if (neighbors.length > 0) {
                        const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                        const wx = current.x + (next.x - current.x) / 2;
                        const wy = current.y + (next.y - current.y) / 2;
                        grid[wy][wx] = PATH;
                        grid[next.y][next.x] = PATH;
                        stack.push(next);
                    } else {
                        stack.pop();
                    }
                }
            }

            function generatePrims() {
                const frontier = [];
                const start = { x: 1, y: 1 };
                grid[start.y][start.x] = PATH;
                addFrontier(start.x, start.y, frontier);

                while (frontier.length > 0) {
                    const idx = Math.floor(Math.random() * frontier.length);
                    const cell = frontier.splice(idx, 1)[0];
                    const neighbors = getPathNeighbors(cell.x, cell.y, 2);

                    if (neighbors.length > 0) {
                        const neighbor = neighbors[Math.floor(Math.random() * neighbors.length)];
                        const wx = cell.x + (neighbor.x - cell.x) / 2;
                        const wy = cell.y + (neighbor.y - cell.y) / 2;
                        grid[wy][wx] = PATH;
                        grid[cell.y][cell.x] = PATH;
                        addFrontier(cell.x, cell.y, frontier);
                    }
                }
            }

            function addFrontier(x, y, frontier) {
                const dirs = [[0, -2], [2, 0], [0, 2], [-2, 0]];
                for (const [dx, dy] of dirs) {
                    const nx = x + dx, ny = y + dy;
                    if (nx > 0 && nx < gridSize - 1 && ny > 0 && ny < gridSize - 1 && grid[ny][nx] === WALL) {
                        if (!frontier.some(f => f.x === nx && f.y === ny)) {
                            frontier.push({ x: nx, y: ny });
                        }
                    }
                }
            }

            function generateKruskals() {
                const walls = [];
                const parent = {};

                for (let y = 1; y < gridSize - 1; y += 2) {
                    for (let x = 1; x < gridSize - 1; x += 2) {
                        const id = `${x},${y}`;
                        parent[id] = id;
                        grid[y][x] = PATH;
                        if (x + 2 < gridSize - 1) walls.push({ x1: x, y1: y, x2: x + 2, y2: y });
                        if (y + 2 < gridSize - 1) walls.push({ x1: x, y1: y, x2: x, y2: y + 2 });
                    }
                }

                for (let i = walls.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [walls[i], walls[j]] = [walls[j], walls[i]];
                }

                function find(id) {
                    if (parent[id] !== id) parent[id] = find(parent[id]);
                    return parent[id];
                }

                for (const wall of walls) {
                    const id1 = `${wall.x1},${wall.y1}`;
                    const id2 = `${wall.x2},${wall.y2}`;
                    if (find(id1) !== find(id2)) {
                        parent[find(id1)] = find(id2);
                        grid[(wall.y1 + wall.y2) / 2][(wall.x1 + wall.x2) / 2] = PATH;
                    }
                }
            }

            function generateBinaryTree() {
                for (let y = 1; y < gridSize - 1; y += 2) {
                    for (let x = 1; x < gridSize - 1; x += 2) {
                        grid[y][x] = PATH;
                        const canGoNorth = y > 2;
                        const canGoEast = x < gridSize - 3;

                        if (canGoNorth && canGoEast) {
                            if (Math.random() < 0.5) grid[y - 1][x] = PATH;
                            else grid[y][x + 1] = PATH;
                        } else if (canGoNorth) {
                            grid[y - 1][x] = PATH;
                        } else if (canGoEast) {
                            grid[y][x + 1] = PATH;
                        }
                    }
                }
            }

            function getUnvisitedNeighbors(x, y, step) {
                const neighbors = [];
                const dirs = [[0, -step], [step, 0], [0, step], [-step, 0]];
                for (const [dx, dy] of dirs) {
                    const nx = x + dx, ny = y + dy;
                    if (nx > 0 && nx < gridSize - 1 && ny > 0 && ny < gridSize - 1 && grid[ny][nx] === WALL) {
                        neighbors.push({ x: nx, y: ny });
                    }
                }
                return neighbors;
            }

            function getPathNeighbors(x, y, step) {
                const neighbors = [];
                const dirs = [[0, -step], [step, 0], [0, step], [-step, 0]];
                for (const [dx, dy] of dirs) {
                    const nx = x + dx, ny = y + dy;
                    if (nx > 0 && nx < gridSize - 1 && ny > 0 && ny < gridSize - 1 && grid[ny][nx] === PATH) {
                        neighbors.push({ x: nx, y: ny });
                    }
                }
                return neighbors;
            }

            // Helper functions for solving
            function getNeighbors(pos) {
                const neighbors = [];
                const dirs = [[0, -1], [1, 0], [0, 1], [-1, 0]];
                for (const [dx, dy] of dirs) {
                    const nx = pos.x + dx, ny = pos.y + dy;
                    if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
                        const cell = grid[ny][nx];
                        if (cell === PATH || cell === END) {
                            neighbors.push({ x: nx, y: ny });
                        }
                    }
                }
                return neighbors;
            }

            function heuristic(a, b) {
                return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
            }

            // Solve maze
            async function solveMaze() {
                if (isAnimating) return;

                clearSolution();
                isAnimating = true;
                document.getElementById('solveBtn').disabled = true;
                document.getElementById('generateBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                document.getElementById('statusDisplay').textContent = 'Solving...';

                let visitedCount = 0;
                let path = null;

                // Create context for the algorithm
                const solveContext = {
                    start: { ...startPos },
                    end: { ...endPos },
                    getNeighbors: getNeighbors,
                    heuristic: heuristic,
                    isRunning: () => isAnimating,
                    visit: async (pos) => {
                        visitedCount++;
                        if (grid[pos.y][pos.x] !== START) {
                            grid[pos.y][pos.x] = VISITED;
                        }
                        draw();
                        updateStats(visitedCount, '-');
                        await new Promise(r => {
                            animationId = setTimeout(r, Math.max(1, 100 - animationSpeed));
                        });
                    }
                };

                try {
                    const code = customCode[solveAlgorithm];
                    const solveFunc = new Function('ctx', `
                        return (async function() {
                            ${code}
                            return solve(ctx);
                        })();
                    `);
                    path = await solveFunc(solveContext);
                    setCodeStatus('Algorithm executed successfully', 'success');
                } catch (err) {
                    setCodeStatus('Error: ' + err.message, 'error');
                    console.error(err);
                }

                if (path && isAnimating) {
                    for (const pos of path) {
                        if (!isAnimating) break;
                        if (grid[pos.y][pos.x] !== START && grid[pos.y][pos.x] !== END) {
                            grid[pos.y][pos.x] = SOLUTION;
                        }
                        draw();
                        await new Promise(r => setTimeout(r, Math.max(5, 50 - animationSpeed / 2)));
                    }
                    document.getElementById('statusDisplay').textContent = 'Solved!';
                    updateStats(visitedCount, path.length);
                } else if (isAnimating) {
                    document.getElementById('statusDisplay').textContent = 'No path found';
                }

                isAnimating = false;
                document.getElementById('solveBtn').disabled = false;
                document.getElementById('generateBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
            }

            function clearSolution() {
                for (let y = 0; y < gridSize; y++) {
                    for (let x = 0; x < gridSize; x++) {
                        if (grid[y][x] === VISITED || grid[y][x] === CURRENT || grid[y][x] === SOLUTION) {
                            grid[y][x] = PATH;
                        }
                    }
                }
                grid[startPos.y][startPos.x] = START;
                grid[endPos.y][endPos.x] = END;
                updateStats(0, '-');
                document.getElementById('statusDisplay').textContent = 'Ready';
                draw();
            }

            function stopAnimation() {
                isAnimating = false;
                if (animationId) {
                    clearTimeout(animationId);
                    animationId = null;
                }
                document.getElementById('solveBtn').disabled = false;
                document.getElementById('generateBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                document.getElementById('statusDisplay').textContent = 'Stopped';
            }

            function updateStats(visited, pathLen) {
                document.getElementById('sizeDisplay').textContent = `${gridSize}x${gridSize}`;
                document.getElementById('visitedDisplay').textContent = visited;
                document.getElementById('pathDisplay').textContent = pathLen;
            }

            // Code editor functions
            function updateCodeEditor() {
                codeEditor.value = customCode[solveAlgorithm];
                setCodeStatus('Ready to edit', '');
            }

            function setCodeStatus(message, type) {
                codeStatus.textContent = message;
                codeStatus.className = 'code-status' + (type ? ' ' + type : '');
            }

            function toggleCodePanel() {
                document.getElementById('codePanel').classList.toggle('open');
            }

            // Event listeners
            document.getElementById('generateBtn').addEventListener('click', generateMaze);
            document.getElementById('solveBtn').addEventListener('click', solveMaze);
            document.getElementById('clearBtn').addEventListener('click', clearSolution);
            document.getElementById('stopBtn').addEventListener('click', stopAnimation);
            document.getElementById('codeBtn').addEventListener('click', toggleCodePanel);

            document.getElementById('runCodeBtn').addEventListener('click', () => {
                customCode[solveAlgorithm] = codeEditor.value;
                setCodeStatus('Code saved. Click Solve to run.', 'success');
            });

            document.getElementById('resetCodeBtn').addEventListener('click', () => {
                customCode[solveAlgorithm] = SOLVE_ALGORITHMS[solveAlgorithm];
                codeEditor.value = SOLVE_ALGORITHMS[solveAlgorithm];
                setCodeStatus('Code reset to default', 'success');
            });

            codeEditor.addEventListener('input', () => {
                setCodeStatus('Modified (click Run to save)', '');
            });

            // Handle tab key in editor
            codeEditor.addEventListener('keydown', (e) => {
                if (e.key === 'Tab') {
                    e.preventDefault();
                    const start = codeEditor.selectionStart;
                    const end = codeEditor.selectionEnd;
                    codeEditor.value = codeEditor.value.substring(0, start) + '  ' + codeEditor.value.substring(end);
                    codeEditor.selectionStart = codeEditor.selectionEnd = start + 2;
                }
            });

            // Algorithm selectors
            document.querySelectorAll('[data-gen]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('[data-gen]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    genAlgorithm = btn.dataset.gen;
                });
            });

            document.querySelectorAll('[data-solve]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('[data-solve]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    solveAlgorithm = btn.dataset.solve;
                    updateCodeEditor();
                });
            });

            // Sliders
            const sizeSlider = document.getElementById('sizeSlider');
            const sizeValue = document.getElementById('sizeValue');
            sizeSlider.addEventListener('input', (e) => {
                gridSize = parseInt(e.target.value);
                sizeValue.textContent = gridSize;
            });
            sizeSlider.addEventListener('change', init);

            const speedSlider = document.getElementById('speedSlider');
            const speedValue = document.getElementById('speedValue');
            speedSlider.addEventListener('input', (e) => {
                animationSpeed = parseInt(e.target.value);
                speedValue.textContent = animationSpeed;
            });

            // Help modal
            const helpModal = document.getElementById('helpModal');
            document.getElementById('helpBtn').addEventListener('click', () => helpModal.classList.add('show'));
            document.getElementById('closeHelp').addEventListener('click', () => helpModal.classList.remove('show'));
            helpModal.addEventListener('click', (e) => {
                if (e.target === helpModal) helpModal.classList.remove('show');
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                switch (e.key.toLowerCase()) {
                    case 'g': generateMaze(); break;
                    case 's': solveMaze(); break;
                    case 'c': clearSolution(); break;
                    case 'e': toggleCodePanel(); break;
                    case 'escape':
                        stopAnimation();
                        if (helpModal.classList.contains('show')) helpModal.classList.remove('show');
                        break;
                }
            });

            // Resize
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(init, 250);
            });

            // Start
            init();
        </script>
    </body>
</html>
