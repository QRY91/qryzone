---
layout: false
permalink: /fun/mandelbrot/
---
<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="description" content="Interactive Mandelbrot and Julia set fractal explorer" />
        <title>Mandelbrot Explorer</title>

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Atkinson+Hyperlegible:ital,wght@0,400;0,700;1,400;1,700&family=Atkinson+Hyperlegible+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="/assets/css/fun-pages.css">

        <style>
            :root {
                --bg-deep: #0a0a12;
                --bg-surface: #10101a;
                --bg-elevated: #181824;
                --accent: #9d4edd;
                --accent-rgb: 157, 78, 221;
                --accent-dim: rgba(157, 78, 221, 0.3);
                --accent-glow: rgba(157, 78, 221, 0.15);
            }

            body.fullscreen .top-btn { background: rgba(10, 10, 18, 0.8); }

            .stats-bar {
                gap: 1.5rem;
                font-size: 0.8rem;
            }

            .stat { gap: 0.4rem; }
            .stat-value { font-size: 0.75rem; }

            .canvas-container { position: relative; }

            #canvas {
                cursor: crosshair;
                touch-action: none;
            }

            .loading-overlay {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: var(--bg-elevated);
                padding: 1rem 2rem;
                border-radius: 4px;
                border: 1px solid var(--border);
                display: none;
                z-index: 50;
            }

            .loading-overlay.show { display: block; }

            .controls { max-width: 750px; }

            .slider-control input[type="range"] { width: 80px; }
            .slider-value { min-width: 35px; }

            .presets-label {
                font-size: 0.75rem;
                color: var(--text-secondary);
            }

            .modal code {
                background: var(--bg-elevated);
                padding: 0.1rem 0.3rem;
                border-radius: 3px;
                color: var(--accent);
            }

            @media (max-width: 480px) {
                .slider-control input[type="range"] { width: 60px; }
            }
        </style>
    </head>
    <body>
        <a href="/fun/" class="back-link">← back</a>
        <button class="top-btn fullscreen-btn" id="fullscreenBtn" title="Fullscreen (F)">⛶</button>
        <button class="top-btn help-btn" id="helpBtn" title="Help (?)">?</button>

        <header class="game-header">
            <h1 class="game-title">Mandelbrot Explorer</h1>
            <div class="stats-bar">
                <div class="stat">
                    <span class="stat-label">Center:</span>
                    <span class="stat-value" id="centerDisplay">0 + 0i</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Zoom:</span>
                    <span class="stat-value" id="zoomDisplay">1x</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Mode:</span>
                    <span class="stat-value" id="modeDisplay">Mandelbrot</span>
                </div>
            </div>
        </header>

        <div class="canvas-container">
            <canvas id="canvas"></canvas>
            <div class="loading-overlay" id="loadingOverlay">Rendering...</div>
        </div>

        <div class="controls">
            <div class="control-row">
                <button class="primary" id="resetBtn">Reset View</button>
                <button id="zoomInBtn">Zoom In</button>
                <button id="zoomOutBtn">Zoom Out</button>
                <button id="juliaBtn">Julia Mode</button>
            </div>
            <div class="control-row">
                <div class="slider-control">
                    <span class="slider-label">Iterations:</span>
                    <input type="range" id="iterSlider" min="50" max="500" value="150">
                    <span class="slider-value" id="iterDisplay">150</span>
                </div>
                <div class="slider-control">
                    <span class="slider-label">Color Shift:</span>
                    <input type="range" id="colorSlider" min="0" max="360" value="0">
                </div>
            </div>
            <div class="control-row">
                <span class="presets-label">Palette:</span>
                <button data-palette="rainbow" class="active">Rainbow</button>
                <button data-palette="fire">Fire</button>
                <button data-palette="ocean">Ocean</button>
                <button data-palette="grayscale">Grayscale</button>
                <button data-palette="neon">Neon</button>
            </div>
            <div class="control-row">
                <span class="presets-label">Locations:</span>
                <button data-location="seahorse">Seahorse Valley</button>
                <button data-location="spiral">Spiral</button>
                <button data-location="elephant">Elephant Valley</button>
                <button data-location="lightning">Lightning</button>
            </div>
        </div>

        <!-- Help Modal -->
        <div class="modal-overlay" id="helpModal">
            <div class="modal">
                <h2>Mandelbrot Explorer</h2>
                <p>Explore the <a href="https://en.wikipedia.org/wiki/Mandelbrot_set" target="_blank" style="color: var(--accent)">Mandelbrot set</a> - the most famous fractal in mathematics.</p>
                <p><strong>Note:</strong> Zoom is limited to ~10<sup>14</sup>x due to 64-bit floating-point precision. Beyond this, pixels map to the same coordinates. True infinite zoom requires <a href="https://en.wikipedia.org/wiki/Plotting_algorithms_for_the_Mandelbrot_set#Perturbation_theory_and_series_approximation" target="_blank" style="color: var(--accent)">perturbation theory</a>.</p>
                <p><strong>Navigation:</strong></p>
                <ul>
                    <li><strong>Click</strong> - Center view on point</li>
                    <li><strong>Shift+Click</strong> - Zoom in 2x</li>
                    <li><strong>Scroll</strong> - Zoom in/out</li>
                    <li><strong>Arrow keys</strong> - Pan view</li>
                </ul>
                <p><strong><a href="https://en.wikipedia.org/wiki/Julia_set" target="_blank" style="color: var(--accent)">Julia Mode</a>:</strong></p>
                <ul>
                    <li>Toggle Julia mode to see the Julia set for the current center point</li>
                    <li>Each point in the Mandelbrot set corresponds to a unique Julia set</li>
                    <li>Points inside the Mandelbrot set produce connected Julia sets</li>
                </ul>
                <p><strong>Keyboard:</strong></p>
                <ul>
                    <li><strong>R</strong> - Reset view</li>
                    <li><strong>J</strong> - Toggle Julia mode</li>
                    <li><strong>+/-</strong> - Zoom in/out</li>
                    <li><strong>F</strong> - Fullscreen</li>
                </ul>
                <button class="modal-close" id="closeHelp">Got it</button>
            </div>
        </div>

        <script>
            // Fractal parameters
            let centerX = -0.5;
            let centerY = 0;
            let zoom = 1;
            let maxIter = 150;
            let colorShift = 0;
            let palette = 'rainbow';
            let juliaMode = false;
            let juliaC = { r: -0.4, i: 0.6 };

            // Canvas
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            let imageData;

            // Palette functions
            const PALETTES = {
                rainbow: (t, shift) => {
                    const h = (t * 360 + shift) % 360;
                    return hslToRgb(h, 100, 50);
                },
                fire: (t, shift) => {
                    const h = (t * 60 + shift) % 360;
                    const l = Math.min(50 + t * 30, 70);
                    return hslToRgb(h, 100, l);
                },
                ocean: (t, shift) => {
                    const h = (180 + t * 60 + shift) % 360;
                    return hslToRgb(h, 80, 40 + t * 30);
                },
                grayscale: (t, shift) => {
                    const v = Math.floor((t + shift / 360) * 255) % 256;
                    return [v, v, v];
                },
                neon: (t, shift) => {
                    const h = (t * 180 + 270 + shift) % 360;
                    return hslToRgb(h, 100, 60);
                }
            };

            function hslToRgb(h, s, l) {
                s /= 100;
                l /= 100;
                const k = n => (n + h / 30) % 12;
                const a = s * Math.min(l, 1 - l);
                const f = n => l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));
                return [Math.floor(f(0) * 255), Math.floor(f(8) * 255), Math.floor(f(4) * 255)];
            }

            // Famous locations
            const LOCATIONS = {
                seahorse: { x: -0.747, y: 0.1, z: 50 },
                spiral: { x: -0.761574, y: -0.0847596, z: 200 },
                elephant: { x: 0.281717921930775, y: 0.5771052841488505, z: 100 },
                lightning: { x: -1.315180982097868, y: 0.073481649996795, z: 50 }
            };

            // Initialize
            function init() {
                const container = document.querySelector('.canvas-container');
                const maxWidth = container.clientWidth - 20;
                const maxHeight = container.clientHeight - 20;
                const size = Math.min(maxWidth, maxHeight, 600);

                canvas.width = size;
                canvas.height = size;
                imageData = ctx.createImageData(size, size);

                render();
            }

            // Render fractal
            function render() {
                const loading = document.getElementById('loadingOverlay');
                loading.classList.add('show');

                // Use setTimeout to allow UI update
                setTimeout(() => {
                    const w = canvas.width;
                    const h = canvas.height;
                    const data = imageData.data;

                    const scale = 4 / zoom;
                    const xMin = centerX - scale / 2;
                    const yMin = centerY - scale / 2;

                    for (let py = 0; py < h; py++) {
                        for (let px = 0; px < w; px++) {
                            const x0 = xMin + (px / w) * scale;
                            const y0 = yMin + (py / h) * scale;

                            let x, y, cr, ci;

                            if (juliaMode) {
                                x = x0;
                                y = y0;
                                cr = juliaC.r;
                                ci = juliaC.i;
                            } else {
                                x = 0;
                                y = 0;
                                cr = x0;
                                ci = y0;
                            }

                            let iter = 0;
                            while (x * x + y * y <= 4 && iter < maxIter) {
                                const xTemp = x * x - y * y + cr;
                                y = 2 * x * y + ci;
                                x = xTemp;
                                iter++;
                            }

                            const idx = (py * w + px) * 4;

                            if (iter === maxIter) {
                                data[idx] = 0;
                                data[idx + 1] = 0;
                                data[idx + 2] = 0;
                            } else {
                                // Smooth coloring
                                const log_zn = Math.log(x * x + y * y) / 2;
                                const nu = Math.log(log_zn / Math.log(2)) / Math.log(2);
                                const smooth = iter + 1 - nu;
                                const t = (smooth / maxIter) % 1;

                                const [r, g, b] = PALETTES[palette](t, colorShift);
                                data[idx] = r;
                                data[idx + 1] = g;
                                data[idx + 2] = b;
                            }
                            data[idx + 3] = 255;
                        }
                    }

                    ctx.putImageData(imageData, 0, 0);
                    updateStats();
                    loading.classList.remove('show');
                }, 10);
            }

            // Update stats
            function updateStats() {
                const sign = centerY >= 0 ? '+' : '';
                document.getElementById('centerDisplay').textContent =
                    `${centerX.toFixed(6)} ${sign} ${centerY.toFixed(6)}i`;
                document.getElementById('zoomDisplay').textContent = zoom.toFixed(0) + 'x';
                document.getElementById('modeDisplay').textContent = juliaMode ? 'Julia' : 'Mandelbrot';
            }

            // Get complex coordinates from canvas position
            function canvasToComplex(px, py) {
                const scale = 4 / zoom;
                return {
                    r: centerX - scale / 2 + (px / canvas.width) * scale,
                    i: centerY - scale / 2 + (py / canvas.height) * scale
                };
            }

            // Canvas click
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const px = e.clientX - rect.left;
                const py = e.clientY - rect.top;
                const c = canvasToComplex(px, py);

                centerX = c.r;
                centerY = c.i;

                if (e.shiftKey) {
                    zoom *= 2;
                }

                if (juliaMode) {
                    juliaC = { r: c.r, i: c.i };
                }

                render();
            });

            // Mouse wheel zoom
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const px = e.clientX - rect.left;
                const py = e.clientY - rect.top;
                const c = canvasToComplex(px, py);

                // Zoom toward mouse position
                const zoomFactor = e.deltaY > 0 ? 0.8 : 1.25;
                centerX = c.r + (centerX - c.r) / zoomFactor;
                centerY = c.i + (centerY - c.i) / zoomFactor;
                zoom *= zoomFactor;

                render();
            });

            // Controls
            document.getElementById('resetBtn').addEventListener('click', () => {
                centerX = juliaMode ? 0 : -0.5;
                centerY = 0;
                zoom = 1;
                render();
            });

            document.getElementById('zoomInBtn').addEventListener('click', () => {
                zoom *= 2;
                render();
            });

            document.getElementById('zoomOutBtn').addEventListener('click', () => {
                zoom /= 2;
                render();
            });

            const juliaBtn = document.getElementById('juliaBtn');
            juliaBtn.addEventListener('click', () => {
                if (!juliaMode) {
                    juliaC = { r: centerX, i: centerY };
                }
                juliaMode = !juliaMode;
                juliaBtn.classList.toggle('active', juliaMode);
                centerX = 0;
                centerY = 0;
                zoom = 1;
                render();
            });

            // Sliders
            const iterSlider = document.getElementById('iterSlider');
            const iterDisplay = document.getElementById('iterDisplay');
            iterSlider.addEventListener('input', (e) => {
                maxIter = parseInt(e.target.value);
                iterDisplay.textContent = maxIter;
            });
            iterSlider.addEventListener('change', render);

            const colorSlider = document.getElementById('colorSlider');
            colorSlider.addEventListener('input', (e) => {
                colorShift = parseInt(e.target.value);
                render();
            });

            // Palette buttons
            document.querySelectorAll('[data-palette]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('[data-palette]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    palette = btn.dataset.palette;
                    render();
                });
            });

            // Location buttons
            document.querySelectorAll('[data-location]').forEach(btn => {
                btn.addEventListener('click', () => {
                    const loc = LOCATIONS[btn.dataset.location];
                    if (loc) {
                        centerX = loc.x;
                        centerY = loc.y;
                        zoom = loc.z;
                        juliaMode = false;
                        juliaBtn.classList.remove('active');
                        render();
                    }
                });
            });

            // Help modal
            const helpModal = document.getElementById('helpModal');
            document.getElementById('helpBtn').addEventListener('click', () => {
                helpModal.classList.add('show');
            });
            document.getElementById('closeHelp').addEventListener('click', () => {
                helpModal.classList.remove('show');
            });
            helpModal.addEventListener('click', (e) => {
                if (e.target === helpModal) helpModal.classList.remove('show');
            });

            // Fullscreen
            let isFullscreen = false;
            const fullscreenBtn = document.getElementById('fullscreenBtn');

            function toggleFullscreen() {
                isFullscreen = !isFullscreen;
                document.body.classList.toggle('fullscreen', isFullscreen);
                fullscreenBtn.title = isFullscreen ? 'Exit Fullscreen (Esc)' : 'Fullscreen (F)';
                setTimeout(init, 50);
            }

            fullscreenBtn.addEventListener('click', toggleFullscreen);

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT') return;

                const panAmount = 0.1 / zoom * 4;

                switch(e.key.toLowerCase()) {
                    case 'f':
                        toggleFullscreen();
                        break;
                    case 'escape':
                        if (isFullscreen) toggleFullscreen();
                        if (helpModal.classList.contains('show')) helpModal.classList.remove('show');
                        break;
                    case 'r':
                        centerX = juliaMode ? 0 : -0.5;
                        centerY = 0;
                        zoom = 1;
                        render();
                        break;
                    case 'j':
                        juliaBtn.click();
                        break;
                    case '=':
                    case '+':
                        zoom *= 2;
                        render();
                        break;
                    case '-':
                        zoom /= 2;
                        render();
                        break;
                    case 'arrowleft':
                        centerX -= panAmount;
                        render();
                        break;
                    case 'arrowright':
                        centerX += panAmount;
                        render();
                        break;
                    case 'arrowup':
                        centerY -= panAmount;
                        render();
                        break;
                    case 'arrowdown':
                        centerY += panAmount;
                        render();
                        break;
                }
            });

            // Resize
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(init, 250);
            });

            // Start
            init();
        </script>
    </body>
</html>
