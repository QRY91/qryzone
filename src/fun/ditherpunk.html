---
layout: false
permalink: /fun/ditherpunk/
explore: true
exploreTitle: "Ditherpunk"
tagline: "Classic dithering algorithms for the permacomputing age"
exploreTags:
  - permacomputing
  - creative
  - design
exploreType: interactive
status: evergreen
---
<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Ditherpunk - Classic dithering algorithms for the permacomputing age">
    <title>Ditherpunk</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Atkinson+Hyperlegible:ital,wght@0,400;0,700;1,400;1,700&family=Atkinson+Hyperlegible+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/fun-pages.css">
    <style>
        .game-header { padding-top: 4rem; }

        .image-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            max-width: 800px;
            margin: 1rem auto;
            padding: 0 1rem;
        }

        .image-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .panel-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .drop-zone {
            width: 100%;
            aspect-ratio: 1;
            max-width: 350px;
            border: 2px dashed var(--border);
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            background: var(--bg-surface);
            position: relative;
            overflow: hidden;
        }

        .drop-zone:hover {
            border-color: var(--accent);
        }

        .drop-zone.drag-over {
            border-color: var(--accent);
            background: var(--accent-glow);
        }

        .drop-zone.has-image {
            border-style: solid;
        }

        .drop-zone-text {
            color: var(--text-secondary);
            font-size: 0.85rem;
            text-align: center;
            padding: 1rem;
        }

        .drop-zone-text span {
            display: block;
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        #originalImage {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            display: none;
        }

        .drop-zone.has-image .drop-zone-text {
            display: none;
        }

        .drop-zone.has-image #originalImage {
            display: block;
        }

        #resultCanvas {
            width: 100%;
            max-width: 350px;
            aspect-ratio: 1;
            background: var(--bg-surface);
            border: 1px solid var(--border);
            border-radius: 4px;
            image-rendering: pixelated;
            object-fit: contain;
        }

        .stats-bar {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 350px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 0.5rem;
            padding: 0 0.25rem;
        }

        .savings {
            color: var(--accent);
            font-weight: bold;
        }

        .controls {
            max-width: 600px;
            margin: 1.5rem auto;
            padding: 0 1rem;
        }

        .control-section {
            margin-bottom: 1rem;
        }

        .control-label {
            font-size: 0.7rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
            display: block;
        }

        .preset-row {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .preset-row button {
            font-size: 0.75rem;
            padding: 0.4rem 0.8rem;
        }

        .preset-row button.active {
            background: var(--accent-glow);
            border-color: var(--accent);
        }

        .slider-row {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            max-width: 300px;
            margin: 0.5rem auto;
        }

        .slider-row label {
            font-size: 0.7rem;
            color: var(--text-secondary);
            min-width: 60px;
        }

        .slider-row input[type="range"] {
            flex: 1;
            accent-color: var(--accent);
        }

        .slider-row .value {
            font-size: 0.7rem;
            color: var(--text-secondary);
            min-width: 35px;
            text-align: right;
        }

        .action-row {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 1.5rem;
        }

        .action-row button {
            font-size: 0.8rem;
            padding: 0.5rem 1rem;
        }

        .attribution {
            text-align: center;
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 2rem;
            padding: 1rem;
        }

        .attribution a {
            color: var(--accent);
        }

        #fileInput {
            display: none;
        }

        .threshold-control {
            display: none;
        }

        .threshold-control.visible {
            display: flex;
        }

        .no-image .stats-bar,
        .no-image #resultCanvas {
            opacity: 0.3;
        }

        @media (max-width: 600px) {
            .image-container {
                grid-template-columns: 1fr;
            }
            .drop-zone, #resultCanvas {
                max-width: 100%;
            }
        }
    </style>
</head>
<body class="no-image">
    <a href="/fun/" class="back-link">&larr; back</a>
    <button class="top-btn help-btn" id="helpBtn" title="Help">?</button>

    <header class="game-header">
        <h1 class="game-title">Ditherpunk</h1>
        <p class="game-subtitle">make compression visible</p>
    </header>

    <div class="image-container">
        <div class="image-panel">
            <div class="panel-label">Original</div>
            <div class="drop-zone" id="dropZone">
                <div class="drop-zone-text">
                    <span>+</span>
                    Drop image here<br>or click to browse
                </div>
                <img id="originalImage" alt="Original image">
            </div>
            <div class="stats-bar">
                <span id="originalSize">-</span>
                <span id="originalDimensions">-</span>
            </div>
        </div>
        <div class="image-panel">
            <div class="panel-label">Dithered</div>
            <canvas id="resultCanvas"></canvas>
            <div class="stats-bar">
                <span id="ditheredSize">-</span>
                <span id="savings" class="savings">-</span>
            </div>
        </div>
    </div>

    <input type="file" id="fileInput" accept="image/*">

    <div class="controls">
        <div class="control-section">
            <span class="control-label">Algorithm</span>
            <div class="preset-row" id="algorithmRow">
                <button class="active" data-algo="floyd-steinberg">Floyd-Steinberg</button>
                <button data-algo="atkinson">Atkinson</button>
                <button data-algo="bayer">Bayer</button>
            </div>
        </div>

        <div class="control-section">
            <span class="control-label">Palette</span>
            <div class="preset-row" id="paletteRow">
                <button data-palette="1bit">1-bit</button>
                <button class="active" data-palette="4gray">4-gray</button>
                <button data-palette="zenburn">Zenburn</button>
            </div>
        </div>

        <div class="slider-row">
            <label>Scale</label>
            <input type="range" id="scaleSlider" min="10" max="100" value="50">
            <span class="value" id="scaleValue">50%</span>
        </div>

        <div class="slider-row threshold-control" id="thresholdControl">
            <label>Threshold</label>
            <input type="range" id="thresholdSlider" min="0" max="255" value="128">
            <span class="value" id="thresholdValue">128</span>
        </div>

        <div class="action-row">
            <button id="exportPngBtn">Export PNG</button>
            <button id="exportAsciiBtn">Export ASCII</button>
            <button id="resetBtn">Reset</button>
        </div>
    </div>

    <div class="attribution">
        Inspired by <a href="https://solar.lowtechmagazine.com/about/the-solar-website/" target="_blank" rel="noopener">Low Tech Magazine's solar website</a>
    </div>

    <div class="modal-overlay" id="helpModal">
        <div class="modal">
            <h2>Ditherpunk</h2>
            <p>Transform images using classic dithering algorithms from the early days of computing.</p>
            <p><strong>Algorithms:</strong></p>
            <ul>
                <li><strong>Floyd-Steinberg</strong> &ndash; Error diffusion, organic look</li>
                <li><strong>Atkinson</strong> &ndash; Mac classic, higher contrast</li>
                <li><strong>Bayer</strong> &ndash; Ordered dithering, crosshatch pattern</li>
            </ul>
            <p><strong>Palettes:</strong></p>
            <ul>
                <li><strong>1-bit</strong> &ndash; Pure black and white</li>
                <li><strong>4-gray</strong> &ndash; Four-level grayscale (Low Tech Magazine style)</li>
                <li><strong>Zenburn</strong> &ndash; This site's color palette</li>
            </ul>
            <p>Dithering makes compression visible rather than invisible&mdash;an honest aesthetic for the permacomputing age.</p>
            <button class="modal-close" id="closeHelp">Got it</button>
        </div>
    </div>

    <script>
        // Palettes
        const PALETTES = {
            '1bit': [
                [0, 0, 0],
                [255, 255, 255]
            ],
            '4gray': [
                [0, 0, 0],
                [85, 85, 85],
                [170, 170, 170],
                [255, 255, 255]
            ],
            'zenburn': [
                [28, 28, 28],      // bg-deep
                [63, 63, 63],      // border
                [140, 140, 140],   // text-secondary
                [220, 220, 204],   // text-primary
                [136, 192, 208]    // accent
            ]
        };

        // Bayer 4x4 matrix
        const BAYER_4 = [
            [ 0,  8,  2, 10],
            [12,  4, 14,  6],
            [ 3, 11,  1,  9],
            [15,  7, 13,  5]
        ];

        // State
        let originalImage = null;
        let originalSize = 0;
        let currentAlgorithm = 'floyd-steinberg';
        let currentPalette = '4gray';
        let scale = 50;
        let threshold = 128;

        // DOM elements
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const originalImg = document.getElementById('originalImage');
        const resultCanvas = document.getElementById('resultCanvas');
        const ctx = resultCanvas.getContext('2d');

        // Utility functions
        function formatBytes(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        function rgbToGray(r, g, b) {
            return 0.299 * r + 0.587 * g + 0.114 * b;
        }

        function findClosestColor(r, g, b, palette) {
            let minDist = Infinity;
            let closest = palette[0];

            for (const color of palette) {
                const dist = Math.sqrt(
                    Math.pow(r - color[0], 2) +
                    Math.pow(g - color[1], 2) +
                    Math.pow(b - color[2], 2)
                );
                if (dist < minDist) {
                    minDist = dist;
                    closest = color;
                }
            }
            return closest;
        }

        // Dithering algorithms
        function floydSteinberg(imageData, palette) {
            const data = imageData.data;
            const w = imageData.width;
            const h = imageData.height;

            // Work with floating point errors
            const errors = new Float32Array(w * h * 3);

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const i = (y * w + x) * 4;
                    const ei = (y * w + x) * 3;

                    // Add accumulated error
                    let r = data[i] + errors[ei];
                    let g = data[i + 1] + errors[ei + 1];
                    let b = data[i + 2] + errors[ei + 2];

                    // Clamp
                    r = Math.max(0, Math.min(255, r));
                    g = Math.max(0, Math.min(255, g));
                    b = Math.max(0, Math.min(255, b));

                    // Find closest palette color
                    const [nr, ng, nb] = findClosestColor(r, g, b, palette);

                    // Set pixel
                    data[i] = nr;
                    data[i + 1] = ng;
                    data[i + 2] = nb;

                    // Calculate error
                    const er = r - nr;
                    const eg = g - ng;
                    const eb = b - nb;

                    // Distribute error (Floyd-Steinberg pattern)
                    // Right: 7/16
                    if (x + 1 < w) {
                        const idx = (y * w + x + 1) * 3;
                        errors[idx] += er * 7 / 16;
                        errors[idx + 1] += eg * 7 / 16;
                        errors[idx + 2] += eb * 7 / 16;
                    }
                    // Bottom-left: 3/16
                    if (x > 0 && y + 1 < h) {
                        const idx = ((y + 1) * w + x - 1) * 3;
                        errors[idx] += er * 3 / 16;
                        errors[idx + 1] += eg * 3 / 16;
                        errors[idx + 2] += eb * 3 / 16;
                    }
                    // Bottom: 5/16
                    if (y + 1 < h) {
                        const idx = ((y + 1) * w + x) * 3;
                        errors[idx] += er * 5 / 16;
                        errors[idx + 1] += eg * 5 / 16;
                        errors[idx + 2] += eb * 5 / 16;
                    }
                    // Bottom-right: 1/16
                    if (x + 1 < w && y + 1 < h) {
                        const idx = ((y + 1) * w + x + 1) * 3;
                        errors[idx] += er * 1 / 16;
                        errors[idx + 1] += eg * 1 / 16;
                        errors[idx + 2] += eb * 1 / 16;
                    }
                }
            }
            return imageData;
        }

        function atkinson(imageData, palette) {
            const data = imageData.data;
            const w = imageData.width;
            const h = imageData.height;

            const errors = new Float32Array(w * h * 3);

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const i = (y * w + x) * 4;
                    const ei = (y * w + x) * 3;

                    let r = data[i] + errors[ei];
                    let g = data[i + 1] + errors[ei + 1];
                    let b = data[i + 2] + errors[ei + 2];

                    r = Math.max(0, Math.min(255, r));
                    g = Math.max(0, Math.min(255, g));
                    b = Math.max(0, Math.min(255, b));

                    const [nr, ng, nb] = findClosestColor(r, g, b, palette);

                    data[i] = nr;
                    data[i + 1] = ng;
                    data[i + 2] = nb;

                    // Atkinson only distributes 6/8 of error (creates lighter result)
                    const er = (r - nr) / 8;
                    const eg = (g - ng) / 8;
                    const eb = (b - nb) / 8;

                    // Atkinson pattern: 6 neighbors, each gets 1/8
                    const neighbors = [
                        [1, 0], [2, 0],           // right, right+2
                        [-1, 1], [0, 1], [1, 1],  // bottom-left, bottom, bottom-right
                        [0, 2]                     // bottom+2
                    ];

                    for (const [dx, dy] of neighbors) {
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx >= 0 && nx < w && ny < h) {
                            const idx = (ny * w + nx) * 3;
                            errors[idx] += er;
                            errors[idx + 1] += eg;
                            errors[idx + 2] += eb;
                        }
                    }
                }
            }
            return imageData;
        }

        function bayer(imageData, palette, threshold) {
            const data = imageData.data;
            const w = imageData.width;
            const h = imageData.height;
            const matrixSize = 4;

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const i = (y * w + x) * 4;

                    let r = data[i];
                    let g = data[i + 1];
                    let b = data[i + 2];

                    // Get threshold offset from Bayer matrix
                    const mx = x % matrixSize;
                    const my = y % matrixSize;
                    const bayerValue = (BAYER_4[my][mx] / 16) - 0.5;

                    // Apply threshold with Bayer offset
                    const offset = bayerValue * threshold;
                    r = Math.max(0, Math.min(255, r + offset));
                    g = Math.max(0, Math.min(255, g + offset));
                    b = Math.max(0, Math.min(255, b + offset));

                    const [nr, ng, nb] = findClosestColor(r, g, b, palette);

                    data[i] = nr;
                    data[i + 1] = ng;
                    data[i + 2] = nb;
                }
            }
            return imageData;
        }

        // Image processing
        function processImage() {
            if (!originalImage) return;

            const scaleFactor = scale / 100;
            const w = Math.floor(originalImage.width * scaleFactor);
            const h = Math.floor(originalImage.height * scaleFactor);

            resultCanvas.width = w;
            resultCanvas.height = h;

            // Draw scaled image
            ctx.drawImage(originalImage, 0, 0, w, h);

            // Get image data
            const imageData = ctx.getImageData(0, 0, w, h);
            const palette = PALETTES[currentPalette];

            // Apply dithering
            let result;
            switch (currentAlgorithm) {
                case 'floyd-steinberg':
                    result = floydSteinberg(imageData, palette);
                    break;
                case 'atkinson':
                    result = atkinson(imageData, palette);
                    break;
                case 'bayer':
                    result = bayer(imageData, palette, threshold);
                    break;
            }

            ctx.putImageData(result, 0, 0);
            updateStats();
        }

        function updateStats() {
            resultCanvas.toBlob((blob) => {
                if (!blob) return;
                const ditheredSize = blob.size;
                const savings = originalSize > 0
                    ? ((1 - ditheredSize / originalSize) * 100).toFixed(0)
                    : 0;

                document.getElementById('ditheredSize').textContent = formatBytes(ditheredSize);
                document.getElementById('savings').textContent =
                    savings > 0 ? `-${savings}%` : (savings < 0 ? `+${Math.abs(savings)}%` : '0%');
            }, 'image/png');
        }

        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    originalImage = img;
                    originalSize = file.size;

                    // Update UI
                    originalImg.src = e.target.result;
                    dropZone.classList.add('has-image');
                    document.body.classList.remove('no-image');

                    document.getElementById('originalSize').textContent = formatBytes(originalSize);
                    document.getElementById('originalDimensions').textContent =
                        `${img.width} x ${img.height}`;

                    processImage();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // Event listeners
        dropZone.addEventListener('click', () => fileInput.click());

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('drag-over');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) {
                loadImage(file);
            }
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) loadImage(file);
        });

        // Algorithm buttons
        document.querySelectorAll('#algorithmRow button').forEach(btn => {
            btn.addEventListener('click', () => {
                currentAlgorithm = btn.dataset.algo;
                document.querySelectorAll('#algorithmRow button').forEach(b =>
                    b.classList.toggle('active', b === btn));

                // Show/hide threshold control for Bayer
                document.getElementById('thresholdControl').classList.toggle(
                    'visible', currentAlgorithm === 'bayer');

                processImage();
            });
        });

        // Palette buttons
        document.querySelectorAll('#paletteRow button').forEach(btn => {
            btn.addEventListener('click', () => {
                currentPalette = btn.dataset.palette;
                document.querySelectorAll('#paletteRow button').forEach(b =>
                    b.classList.toggle('active', b === btn));
                processImage();
            });
        });

        // Sliders
        document.getElementById('scaleSlider').addEventListener('input', function() {
            scale = parseInt(this.value);
            document.getElementById('scaleValue').textContent = scale + '%';
            processImage();
        });

        document.getElementById('thresholdSlider').addEventListener('input', function() {
            threshold = parseInt(this.value);
            document.getElementById('thresholdValue').textContent = threshold;
            processImage();
        });

        // Export buttons
        document.getElementById('exportPngBtn').addEventListener('click', () => {
            if (!originalImage) return;
            const link = document.createElement('a');
            link.download = 'ditherpunk-' + Date.now() + '.png';
            link.href = resultCanvas.toDataURL('image/png');
            link.click();
        });

        document.getElementById('exportAsciiBtn').addEventListener('click', () => {
            if (!originalImage) return;

            const ASCII_CHARS = ' .:-=+*#%@';
            const imageData = ctx.getImageData(0, 0, resultCanvas.width, resultCanvas.height);
            const data = imageData.data;

            let ascii = '';
            for (let y = 0; y < resultCanvas.height; y += 2) { // Skip rows for aspect ratio
                for (let x = 0; x < resultCanvas.width; x++) {
                    const i = (y * resultCanvas.width + x) * 4;
                    const gray = rgbToGray(data[i], data[i + 1], data[i + 2]);
                    const charIndex = Math.floor(gray / 255 * (ASCII_CHARS.length - 1));
                    ascii += ASCII_CHARS[charIndex];
                }
                ascii += '\n';
            }

            const blob = new Blob([ascii], { type: 'text/plain' });
            const link = document.createElement('a');
            link.download = 'ditherpunk-ascii-' + Date.now() + '.txt';
            link.href = URL.createObjectURL(blob);
            link.click();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            originalImage = null;
            originalSize = 0;
            originalImg.src = '';
            dropZone.classList.remove('has-image');
            document.body.classList.add('no-image');

            ctx.clearRect(0, 0, resultCanvas.width, resultCanvas.height);
            resultCanvas.width = 350;
            resultCanvas.height = 350;

            document.getElementById('originalSize').textContent = '-';
            document.getElementById('originalDimensions').textContent = '-';
            document.getElementById('ditheredSize').textContent = '-';
            document.getElementById('savings').textContent = '-';
        });

        // Help modal
        const helpModal = document.getElementById('helpModal');
        document.getElementById('helpBtn').addEventListener('click', () =>
            helpModal.classList.add('show'));
        document.getElementById('closeHelp').addEventListener('click', () =>
            helpModal.classList.remove('show'));
        helpModal.addEventListener('click', (e) => {
            if (e.target === helpModal) helpModal.classList.remove('show');
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') helpModal.classList.remove('show');
        });

        // Initialize canvas size
        resultCanvas.width = 350;
        resultCanvas.height = 350;
    </script>
</body>
</html>
