---
layout: false
permalink: /fun/turtle/
---
<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="description" content="Turtle graphics programming with visual blocks. Draw spirals, stars, and fractals." />
        <title>Turtle Graphics</title>

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="/assets/css/fun-pages.css">

        <style>
            :root {
                --accent: #00ffaa;
                --accent-rgb: 0, 255, 170;
                --accent-dim: rgba(0, 255, 170, 0.3);
                --accent-glow: rgba(0, 255, 170, 0.15);
                --accent-secondary: #ff6b9d;
            }

            body.fullscreen .main-container { display: none; }

            body.fullscreen .canvas-wrapper {
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
            }

            body.fullscreen #canvas {
                border: none;
                width: 100%;
                height: 100%;
            }

            .stats-bar { margin-bottom: 0.5rem; }

            .main-container {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 1rem;
                padding: 0 1rem;
                flex: 1;
                max-width: 1200px;
                margin: 0 auto;
                width: 100%;
            }

            .canvas-wrapper {
                display: flex;
                justify-content: center;
                align-items: flex-start;
            }

            .canvas-stack { position: relative; }

            #canvas, #turtleCanvas {
                border: 1px solid var(--border);
                max-width: 100%;
            }

            #canvas { background: var(--bg-surface); }

            #turtleCanvas {
                position: absolute;
                top: 0;
                left: 0;
                pointer-events: none;
                border-color: transparent;
            }

            .editor-panel {
                background: var(--bg-surface);
                border: 1px solid var(--border);
                border-radius: 4px;
                display: flex;
                flex-direction: column;
                max-height: 500px;
            }

            .editor-header {
                padding: 0.75rem;
                border-bottom: 1px solid var(--border);
                font-size: 0.85rem;
                color: var(--text-secondary);
                display: flex;
                justify-content: space-between;
                align-items: center;
                gap: 0.5rem;
            }

            .editor-header .toggle-group {
                display: flex;
                gap: 0.25rem;
            }

            .editor-header .toggle-btn {
                padding: 0.2rem 0.5rem;
                font-size: 0.7rem;
                opacity: 0.6;
            }

            .editor-header .toggle-btn.active {
                opacity: 1;
                background: var(--accent-glow);
                border-color: var(--accent);
            }

            .command-list {
                flex: 1;
                overflow-y: auto;
                padding: 0.5rem;
            }

            .code-editor {
                flex: 1;
                display: none;
                padding: 0.5rem;
            }

            .code-editor.active { display: block; }

            .code-editor textarea {
                width: 100%;
                height: 100%;
                min-height: 200px;
                background: var(--bg-deep);
                border: 1px solid var(--border);
                border-radius: 3px;
                color: var(--text-primary);
                font-family: 'JetBrains Mono', monospace;
                font-size: 0.8rem;
                padding: 0.5rem;
                resize: none;
                line-height: 1.5;
            }

            .code-editor textarea:focus {
                outline: none;
                border-color: var(--accent);
            }

            .command-list.hidden { display: none; }
            .add-command.hidden { display: none; }

            .command-row {
                display: flex;
                align-items: center;
                gap: 0.5rem;
                padding: 0.4rem 0.5rem;
                background: var(--bg-elevated);
                border-radius: 3px;
                margin-bottom: 0.25rem;
                font-size: 0.8rem;
                cursor: grab;
                transition: opacity 0.15s, background 0.15s;
            }

            .command-row:active { cursor: grabbing; }
            .command-row.dragging { opacity: 0.4; }

            .command-row.drag-over {
                background: var(--accent-glow);
                border: 1px dashed var(--accent);
                margin-top: -1px;
                margin-bottom: calc(0.25rem - 1px);
            }

            .drag-handle {
                color: var(--text-secondary);
                opacity: 0.4;
                font-size: 0.7rem;
                cursor: grab;
                user-select: none;
            }

            .drag-handle:hover { opacity: 0.8; }

            .command-row.nested-1 { margin-left: 1.5rem; }
            .command-row.nested-2 { margin-left: 3rem; }

            .command-row.block-end {
                background: transparent;
                cursor: default;
                color: var(--text-secondary);
            }

            .cmd-name {
                color: var(--accent);
                min-width: 70px;
            }

            .cmd-arg {
                width: 60px;
                background: var(--bg-deep);
                border: 1px solid var(--border);
                border-radius: 3px;
                color: var(--text-primary);
                padding: 0.2rem 0.4rem;
                font-family: inherit;
                font-size: 0.8rem;
                text-align: center;
            }

            .cmd-arg:focus {
                outline: none;
                border-color: var(--accent);
            }

            .cmd-arg[type="color"] {
                width: 40px;
                height: 24px;
                padding: 0;
                cursor: pointer;
            }

            .arg-label {
                color: var(--text-secondary);
                font-size: 0.75rem;
            }

            .delete-cmd {
                margin-left: auto;
                background: none;
                border: none;
                color: var(--text-secondary);
                cursor: pointer;
                font-size: 1rem;
                padding: 0 0.25rem;
                opacity: 0.5;
            }

            .delete-cmd:hover {
                color: var(--accent-secondary);
                opacity: 1;
            }

            .add-command {
                padding: 0.75rem;
                border-top: 1px solid var(--border);
                display: flex;
                gap: 0.5rem;
            }

            .add-command select {
                flex: 1;
                background: var(--bg-elevated);
                border: 1px solid var(--border);
                border-radius: 4px;
                color: var(--text-primary);
                padding: 0.4rem;
                font-family: inherit;
                font-size: 0.8rem;
                cursor: pointer;
            }

            .add-command select:focus {
                outline: none;
                border-color: var(--accent);
            }

            .controls {
                max-width: 1200px;
                width: 100%;
            }

            button.primary:hover {
                background: rgba(0, 255, 170, 0.25);
            }

            button.small {
                padding: 0.3rem 0.6rem;
                font-size: 0.75rem;
            }

            .slider-control input[type="range"] { width: 100px; }
            .slider-value { min-width: 40px; }

            .presets-label {
                font-size: 0.75rem;
                color: var(--text-secondary);
                margin-right: 0.25rem;
            }

            .modal code {
                background: var(--bg-elevated);
                padding: 0.1rem 0.3rem;
                border-radius: 3px;
                color: var(--accent);
            }

            @media (max-width: 768px) {
                .main-container { grid-template-columns: 1fr; }
                .editor-panel { max-height: 250px; }
            }
        </style>
    </head>
    <body>
        <a href="/fun/" class="back-link">&larr; back</a>
        <button class="top-btn fullscreen-btn" id="fullscreenBtn" title="Fullscreen (F)">&#x26F6;</button>
        <button class="top-btn help-btn" id="helpBtn" title="Help (?)">?</button>

        <header class="game-header">
            <h1 class="game-title">Turtle Graphics</h1>
            <div class="stats-bar">
                <div class="stat">
                    <span class="stat-label">Step:</span>
                    <span class="stat-value" id="stepDisplay">0 / 0</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Position:</span>
                    <span class="stat-value" id="posDisplay">0, 0</span>
                </div>
                <div class="stat">
                    <span class="stat-label" id="statusLabel">Ready</span>
                </div>
            </div>
        </header>

        <div class="main-container">
            <div class="canvas-wrapper">
                <div class="canvas-stack">
                    <canvas id="canvas"></canvas>
                    <canvas id="turtleCanvas"></canvas>
                </div>
            </div>

            <div class="editor-panel">
                <div class="editor-header">
                    <span>Program</span>
                    <div class="toggle-group">
                        <button class="small toggle-btn active" id="blocksBtn">Blocks</button>
                        <button class="small toggle-btn" id="codeBtn">Code</button>
                    </div>
                    <button class="small" id="clearProgramBtn">Clear</button>
                </div>
                <div class="command-list" id="commandList">
                    <!-- Commands inserted here -->
                </div>
                <div class="code-editor" id="codeEditor">
                    <textarea id="codeTextarea" spellcheck="false" placeholder="forward 100&#10;right 90&#10;repeat 4 {&#10;  forward 50&#10;  left 90&#10;}"></textarea>
                </div>
                <div class="add-command">
                    <select id="commandSelect">
                        <option value="forward">forward</option>
                        <option value="backward">backward</option>
                        <option value="left">left</option>
                        <option value="right">right</option>
                        <option value="penUp">pen up</option>
                        <option value="penDown">pen down</option>
                        <option value="setColor">set color</option>
                        <option value="setWidth">set width</option>
                        <option value="goto">go to</option>
                        <option value="home">home</option>
                        <option value="set">set variable</option>
                        <option value="repeat">repeat</option>
                        <option value="endrepeat">} end repeat</option>
                    </select>
                    <button class="small" id="addCommandBtn">+ Add</button>
                </div>
            </div>
        </div>

        <div class="controls">
            <div class="control-row">
                <button class="primary" id="runBtn">Run</button>
                <button id="stepBtn">Step</button>
                <button id="resetBtn">Reset</button>
                <button id="clearCanvasBtn">Clear Canvas</button>
            </div>
            <div class="control-row">
                <div class="slider-control">
                    <span class="slider-label">Speed:</span>
                    <input type="range" id="speedSlider" min="1" max="100" value="50">
                    <span class="slider-value" id="speedDisplay">50ms</span>
                </div>
            </div>
            <div class="control-row">
                <span class="presets-label">Presets:</span>
                <button data-preset="square">Square</button>
                <button data-preset="spiral">Spiral</button>
                <button data-preset="star">Star</button>
                <button data-preset="flower">Flower</button>
                <button data-preset="koch">Koch</button>
                <button data-preset="rainbow">Rainbow</button>
            </div>
        </div>

        <!-- Help Modal -->
        <div class="modal-overlay" id="helpModal">
            <div class="modal">
                <h2>Turtle Graphics</h2>
                <p>Create drawings by programming a virtual turtle. The turtle carries a pen and moves around the canvas following your commands. Based on <a href="https://en.wikipedia.org/wiki/Logo_(programming_language)" target="_blank" style="color: var(--accent)">Logo</a>, the language from Seymour Papert's <a href="https://en.wikipedia.org/wiki/Mindstorms_(book)" target="_blank" style="color: var(--accent)">Mindstorms</a> (1980).</p>
                <p><strong>Commands:</strong></p>
                <ul>
                    <li><code>forward</code> / <code>backward</code> - Move in pixels</li>
                    <li><code>left</code> / <code>right</code> - Turn in degrees</li>
                    <li><code>pen up</code> / <code>pen down</code> - Lift or lower the pen</li>
                    <li><code>set color</code> - Change pen color</li>
                    <li><code>set width</code> - Change line thickness</li>
                    <li><code>go to</code> - Jump to coordinates</li>
                    <li><code>home</code> - Return to center</li>
                    <li><code>repeat</code> - Loop commands N times</li>
                    <li><code>set</code> - Create/update a variable</li>
                </ul>
                <p><strong>Variables:</strong></p>
                <ul>
                    <li><code>set size 5</code> - Create variable</li>
                    <li><code>forward size</code> - Use variable</li>
                    <li><code>set size size + 5</code> - Math expressions</li>
                </ul>
                <p><strong>Keyboard:</strong></p>
                <ul>
                    <li><code>Space</code> - Run / Pause</li>
                    <li><code>S</code> - Single step</li>
                    <li><code>R</code> - Reset turtle</li>
                    <li><code>C</code> - Clear canvas</li>
                    <li><code>F</code> - Fullscreen</li>
                    <li><code>1-6</code> - Load presets</li>
                </ul>
                <button class="modal-close" id="closeHelp">Got it</button>
            </div>
        </div>

        <script>
            // Command definitions
            const COMMANDS = {
                forward: { args: ['distance'], defaults: [100], labels: ['px'] },
                backward: { args: ['distance'], defaults: [50], labels: ['px'] },
                left: { args: ['angle'], defaults: [90], labels: ['\u00B0'] },
                right: { args: ['angle'], defaults: [90], labels: ['\u00B0'] },
                penUp: { args: [], defaults: [], labels: [] },
                penDown: { args: [], defaults: [], labels: [] },
                setColor: { args: ['color'], defaults: ['#00ffaa'], labels: [''], type: 'color' },
                setWidth: { args: ['width'], defaults: [2], labels: ['px'] },
                goto: { args: ['x', 'y'], defaults: [0, 0], labels: ['x', 'y'] },
                home: { args: [], defaults: [], labels: [] },
                repeat: { args: ['count'], defaults: [4], labels: ['\u00D7'], hasBlock: true },
                endrepeat: { args: [], defaults: [], labels: [], isBlockEnd: true },
                set: { args: ['name', 'value'], defaults: ['size', '5'], labels: ['=', ''], type: 'variable' }
            };

            // Presets
            const PRESETS = {
                square: [
                    { cmd: 'repeat', args: [4] },
                    { cmd: 'forward', args: [100] },
                    { cmd: 'right', args: [90] },
                    { cmd: 'endrepeat', args: [] }
                ],
                spiral: [
                    { cmd: 'set', args: ['size', '5'] },
                    { cmd: 'repeat', args: [20] },
                    { cmd: 'forward', args: ['size'] },
                    { cmd: 'right', args: [90] },
                    { cmd: 'set', args: ['size', 'size + 5'] },
                    { cmd: 'endrepeat', args: [] }
                ],
                star: [
                    { cmd: 'setColor', args: ['#ffd700'] },
                    { cmd: 'repeat', args: [5] },
                    { cmd: 'forward', args: [100] },
                    { cmd: 'right', args: [144] },
                    { cmd: 'endrepeat', args: [] }
                ],
                flower: [
                    { cmd: 'setColor', args: ['#ff6b9d'] },
                    { cmd: 'repeat', args: [8] },
                    { cmd: 'repeat', args: [45] },
                    { cmd: 'forward', args: [3] },
                    { cmd: 'right', args: [4] },
                    { cmd: 'endrepeat', args: [] },
                    { cmd: 'right', args: [45] },
                    { cmd: 'endrepeat', args: [] }
                ],
                koch: [
                    { cmd: 'setColor', args: ['#00bfff'] },
                    { cmd: 'setWidth', args: [2] },
                    { cmd: 'left', args: [60] },
                    { cmd: 'repeat', args: [3] },
                    { cmd: 'forward', args: [20] },
                    { cmd: 'left', args: [60] },
                    { cmd: 'forward', args: [20] },
                    { cmd: 'right', args: [120] },
                    { cmd: 'forward', args: [20] },
                    { cmd: 'left', args: [60] },
                    { cmd: 'forward', args: [20] },
                    { cmd: 'right', args: [120] },
                    { cmd: 'endrepeat', args: [] }
                ],
                rainbow: [
                    { cmd: 'setWidth', args: [3] },
                    { cmd: 'setColor', args: ['#ff0000'] },
                    { cmd: 'repeat', args: [30] },
                    { cmd: 'forward', args: [8] },
                    { cmd: 'right', args: [12] },
                    { cmd: 'endrepeat', args: [] },
                    { cmd: 'setColor', args: ['#ff7f00'] },
                    { cmd: 'repeat', args: [30] },
                    { cmd: 'forward', args: [8] },
                    { cmd: 'right', args: [12] },
                    { cmd: 'endrepeat', args: [] },
                    { cmd: 'setColor', args: ['#ffff00'] },
                    { cmd: 'repeat', args: [30] },
                    { cmd: 'forward', args: [8] },
                    { cmd: 'right', args: [12] },
                    { cmd: 'endrepeat', args: [] },
                    { cmd: 'setColor', args: ['#00ff00'] },
                    { cmd: 'repeat', args: [30] },
                    { cmd: 'forward', args: [8] },
                    { cmd: 'right', args: [12] },
                    { cmd: 'endrepeat', args: [] },
                    { cmd: 'setColor', args: ['#0000ff'] },
                    { cmd: 'repeat', args: [30] },
                    { cmd: 'forward', args: [8] },
                    { cmd: 'right', args: [12] },
                    { cmd: 'endrepeat', args: [] },
                    { cmd: 'setColor', args: ['#8b00ff'] },
                    { cmd: 'repeat', args: [30] },
                    { cmd: 'forward', args: [8] },
                    { cmd: 'right', args: [12] },
                    { cmd: 'endrepeat', args: [] }
                ]
            };

            // State
            let program = [];
            let compiledProgram = [];  // Nested structure with blocks
            let execStack = [];  // Stack of {block, index, loopCount, loopMax}
            let totalSteps = 0;
            let executedSteps = 0;
            let isRunning = false;
            let animationId = null;
            let speed = 50;
            let codeMode = false;

            // Turtle state
            let turtle = {
                x: 0,
                y: 0,
                angle: -90,
                penDown: true,
                color: '#00ffaa',
                width: 2
            };

            // Variables for user programs
            let variables = {};

            // Canvas
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const turtleCanvas = document.getElementById('turtleCanvas');
            const turtleCtx = turtleCanvas.getContext('2d');

            // Initialize canvas
            function initCanvas() {
                const wrapper = document.querySelector('.canvas-wrapper');
                const size = Math.min(wrapper.clientWidth - 20, 500);
                canvas.width = size;
                canvas.height = size;
                turtleCanvas.width = size;
                turtleCanvas.height = size;
                clearCanvas();
            }

            // Clear canvas
            function clearCanvas() {
                ctx.fillStyle = '#0a0a0f';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw grid
                ctx.strokeStyle = 'rgba(42, 42, 58, 0.5)';
                ctx.lineWidth = 1;
                const step = 50;
                for (let x = step; x < canvas.width; x += step) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                for (let y = step; y < canvas.height; y += step) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }

                // Draw center crosshair
                ctx.strokeStyle = 'rgba(0, 255, 170, 0.3)';
                ctx.beginPath();
                ctx.moveTo(canvas.width / 2, 0);
                ctx.lineTo(canvas.width / 2, canvas.height);
                ctx.moveTo(0, canvas.height / 2);
                ctx.lineTo(canvas.width, canvas.height / 2);
                ctx.stroke();
            }

            // Reset turtle
            function resetTurtle() {
                turtle = {
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    angle: -90,
                    penDown: true,
                    color: '#00ffaa',
                    width: 2
                };
                updateStats();
                drawTurtle();
            }

            // Draw turtle cursor
            function drawTurtle() {
                // Clear turtle overlay
                turtleCtx.clearRect(0, 0, turtleCanvas.width, turtleCanvas.height);

                // Save canvas state
                turtleCtx.save();
                turtleCtx.translate(turtle.x, turtle.y);
                turtleCtx.rotate((turtle.angle + 90) * Math.PI / 180);

                // Triangle turtle
                turtleCtx.beginPath();
                turtleCtx.moveTo(0, -10);
                turtleCtx.lineTo(-7, 8);
                turtleCtx.lineTo(7, 8);
                turtleCtx.closePath();

                turtleCtx.fillStyle = turtle.penDown ? 'rgba(0, 255, 170, 0.8)' : 'rgba(255, 100, 100, 0.5)';
                turtleCtx.fill();
                turtleCtx.strokeStyle = '#ffffff';
                turtleCtx.lineWidth = 1;
                turtleCtx.stroke();

                turtleCtx.restore();
            }

            // Evaluate an expression (number, variable, or simple math)
            function evaluate(expr) {
                if (typeof expr === 'number') return expr;
                if (typeof expr !== 'string') return parseFloat(expr) || 0;

                expr = expr.trim();

                // Check for math operations
                const addMatch = expr.match(/^(\w+)\s*\+\s*(.+)$/);
                if (addMatch) {
                    return evaluate(addMatch[1]) + evaluate(addMatch[2]);
                }
                const subMatch = expr.match(/^(\w+)\s*-\s*(.+)$/);
                if (subMatch) {
                    return evaluate(subMatch[1]) - evaluate(subMatch[2]);
                }
                const mulMatch = expr.match(/^(\w+)\s*\*\s*(.+)$/);
                if (mulMatch) {
                    return evaluate(mulMatch[1]) * evaluate(mulMatch[2]);
                }

                // Check if it's a variable
                if (variables.hasOwnProperty(expr)) {
                    return variables[expr];
                }

                // Try parsing as number
                return parseFloat(expr) || 0;
            }

            // Build nested program structure from flat list
            function buildNestedProgram(instructions) {
                const result = [];
                let i = 0;

                while (i < instructions.length) {
                    const instr = instructions[i];

                    if (instr.cmd === 'repeat') {
                        // Find matching endrepeat and extract block
                        let depth = 1;
                        let j = i + 1;
                        const blockInstrs = [];
                        while (j < instructions.length && depth > 0) {
                            if (instructions[j].cmd === 'repeat') depth++;
                            else if (instructions[j].cmd === 'endrepeat') depth--;
                            if (depth > 0) blockInstrs.push(instructions[j]);
                            j++;
                        }
                        result.push({
                            cmd: 'repeat',
                            args: [...instr.args],
                            block: buildNestedProgram(blockInstrs)
                        });
                        i = j;
                    } else if (instr.cmd === 'endrepeat') {
                        i++;
                    } else {
                        result.push({ cmd: instr.cmd, args: [...instr.args] });
                        i++;
                    }
                }

                return result;
            }

            // Count total steps (for progress display)
            function countSteps(block, depth = 0) {
                if (depth > 10) return 0;  // Prevent infinite recursion
                let count = 0;
                for (const instr of block) {
                    if (instr.cmd === 'repeat' && instr.block) {
                        const repeatCount = evaluate(instr.args[0]);
                        count += countSteps(instr.block, depth + 1) * repeatCount;
                    } else if (instr.cmd !== 'endrepeat') {
                        count++;
                    }
                }
                return count;
            }

            // Compile program
            function compile() {
                if (codeMode) {
                    syncFromCode();
                }
                program = getProgramFromEditor();
                compiledProgram = buildNestedProgram(program);
                variables = {};
                execStack = [{ block: compiledProgram, index: 0 }];
                executedSteps = 0;
                totalSteps = countSteps(compiledProgram);
                updateStats();
            }

            // Execute single step
            function executeStep() {
                if (execStack.length === 0) return false;

                const frame = execStack[execStack.length - 1];

                // Check if we've finished this block
                if (frame.index >= frame.block.length) {
                    // If this is a loop frame, check if we need to repeat
                    if (frame.loopMax !== undefined) {
                        frame.loopCount++;
                        if (frame.loopCount < frame.loopMax) {
                            frame.index = 0;
                            return true;
                        }
                    }
                    execStack.pop();
                    return execStack.length > 0;
                }

                const instr = frame.block[frame.index];
                frame.index++;

                // Handle repeat by pushing new frame
                if (instr.cmd === 'repeat' && instr.block) {
                    const count = Math.floor(evaluate(instr.args[0]));
                    if (count > 0) {
                        execStack.push({
                            block: instr.block,
                            index: 0,
                            loopCount: 0,
                            loopMax: count
                        });
                    }
                    return true;
                }

                // Execute the instruction
                switch (instr.cmd) {
                    case 'forward':
                        moveTurtle(evaluate(instr.args[0]));
                        break;
                    case 'backward':
                        moveTurtle(-evaluate(instr.args[0]));
                        break;
                    case 'left':
                        turtle.angle -= evaluate(instr.args[0]);
                        break;
                    case 'right':
                        turtle.angle += evaluate(instr.args[0]);
                        break;
                    case 'penUp':
                        turtle.penDown = false;
                        break;
                    case 'penDown':
                        turtle.penDown = true;
                        break;
                    case 'setColor':
                        turtle.color = instr.args[0];
                        break;
                    case 'setWidth':
                        turtle.width = evaluate(instr.args[0]);
                        break;
                    case 'goto':
                        turtle.x = canvas.width / 2 + evaluate(instr.args[0]);
                        turtle.y = canvas.height / 2 - evaluate(instr.args[1]);
                        break;
                    case 'home':
                        turtle.x = canvas.width / 2;
                        turtle.y = canvas.height / 2;
                        turtle.angle = -90;
                        break;
                    case 'set':
                        const varName = instr.args[0];
                        const varValue = evaluate(instr.args[1]);
                        variables[varName] = varValue;
                        break;
                }

                executedSteps++;
                updateStats();
                return execStack.length > 0;
            }

            function moveTurtle(distance) {
                const rad = turtle.angle * Math.PI / 180;
                const newX = turtle.x + distance * Math.cos(rad);
                const newY = turtle.y + distance * Math.sin(rad);

                if (turtle.penDown) {
                    ctx.beginPath();
                    ctx.moveTo(turtle.x, turtle.y);
                    ctx.lineTo(newX, newY);
                    ctx.strokeStyle = turtle.color;
                    ctx.lineWidth = turtle.width;
                    ctx.lineCap = 'round';
                    ctx.stroke();
                }

                turtle.x = newX;
                turtle.y = newY;
            }

            // Animation loop
            function animate() {
                if (!isRunning) return;

                const hasMore = executeStep();
                drawTurtle();

                if (hasMore) {
                    animationId = setTimeout(animate, 101 - speed);
                } else {
                    isRunning = false;
                    updateStatus('Complete');
                    document.getElementById('runBtn').textContent = 'Run';
                }
            }

            // Update stats
            function updateStats() {
                document.getElementById('stepDisplay').textContent =
                    `${executedSteps} / ${totalSteps || '?'}`;
                document.getElementById('posDisplay').textContent =
                    `${Math.round(turtle.x - canvas.width/2)}, ${Math.round(canvas.height/2 - turtle.y)}`;
            }

            function updateStatus(text) {
                document.getElementById('statusLabel').textContent = text;
            }

            // Editor functions
            function renderEditor() {
                const list = document.getElementById('commandList');
                list.innerHTML = '';

                let depth = 0;
                program.forEach((instr, index) => {
                    if (instr.cmd === 'endrepeat') depth = Math.max(0, depth - 1);

                    const row = createCommandRow(instr.cmd, instr.args, depth, index);
                    list.appendChild(row);

                    if (instr.cmd === 'repeat') depth++;
                });
            }

            // Drag and drop state
            let draggedIndex = null;

            function createCommandRow(cmd, args, depth, index) {
                const def = COMMANDS[cmd];
                const row = document.createElement('div');
                row.className = 'command-row';
                if (depth > 0) row.classList.add(`nested-${Math.min(depth, 2)}`);
                if (def.isBlockEnd) row.classList.add('block-end');
                row.dataset.index = index;

                // Make draggable (except block ends)
                if (!def.isBlockEnd) {
                    row.draggable = true;
                }

                let html = '';
                if (!def.isBlockEnd) {
                    html += `<span class="drag-handle">\u2261</span>`;
                }
                html += `<span class="cmd-name">${def.isBlockEnd ? '}' : (cmd === 'set' ? 'set' : cmd)}</span>`;

                if (def.args) {
                    def.args.forEach((argName, i) => {
                        const value = args[i] !== undefined ? args[i] : def.defaults[i];
                        if (def.type === 'color') {
                            html += `<input type="color" class="cmd-arg" data-arg="${i}" value="${value}">`;
                        } else if (def.type === 'variable') {
                            // Text input for variable names and expressions
                            html += `<input type="text" class="cmd-arg" data-arg="${i}" value="${value}" style="width: ${i === 0 ? '50px' : '80px'}">`;
                        } else {
                            // Check if value might be an expression (contains letters)
                            const isExpr = typeof value === 'string' && /[a-zA-Z]/.test(value);
                            if (isExpr) {
                                html += `<input type="text" class="cmd-arg" data-arg="${i}" value="${value}" style="width: 80px">`;
                            } else {
                                html += `<input type="number" class="cmd-arg" data-arg="${i}" value="${value}">`;
                            }
                        }
                        if (def.labels[i]) {
                            html += `<span class="arg-label">${def.labels[i]}</span>`;
                        }
                    });
                }

                if (!def.isBlockEnd) {
                    html += `<button class="delete-cmd" data-index="${index}">\u00D7</button>`;
                }

                row.innerHTML = html;

                // Event listeners for inputs
                row.querySelectorAll('.cmd-arg').forEach(input => {
                    input.addEventListener('change', (e) => {
                        const argIndex = parseInt(e.target.dataset.arg);
                        let value;
                        if (e.target.type === 'color') {
                            value = e.target.value;
                        } else if (e.target.type === 'text') {
                            value = e.target.value;  // Keep as string for variables/expressions
                        } else {
                            value = parseFloat(e.target.value);
                        }
                        program[index].args[argIndex] = value;
                    });
                });

                // Delete button
                const deleteBtn = row.querySelector('.delete-cmd');
                if (deleteBtn) {
                    deleteBtn.addEventListener('click', (e) => {
                        const idx = parseInt(e.target.dataset.index);
                        // If it's a repeat, also remove matching endrepeat
                        if (program[idx].cmd === 'repeat') {
                            let depth = 1;
                            let j = idx + 1;
                            while (j < program.length && depth > 0) {
                                if (program[j].cmd === 'repeat') depth++;
                                else if (program[j].cmd === 'endrepeat') depth--;
                                j++;
                            }
                            program.splice(idx, j - idx);
                        } else {
                            program.splice(idx, 1);
                        }
                        renderEditor();
                    });
                }

                // Drag and drop events
                if (!def.isBlockEnd) {
                    row.addEventListener('dragstart', (e) => {
                        draggedIndex = index;
                        row.classList.add('dragging');
                        e.dataTransfer.effectAllowed = 'move';
                    });

                    row.addEventListener('dragend', () => {
                        row.classList.remove('dragging');
                        draggedIndex = null;
                        document.querySelectorAll('.command-row.drag-over').forEach(r => {
                            r.classList.remove('drag-over');
                        });
                    });

                    row.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'move';
                        if (draggedIndex !== null && draggedIndex !== index) {
                            row.classList.add('drag-over');
                        }
                    });

                    row.addEventListener('dragleave', () => {
                        row.classList.remove('drag-over');
                    });

                    row.addEventListener('drop', (e) => {
                        e.preventDefault();
                        row.classList.remove('drag-over');
                        if (draggedIndex !== null && draggedIndex !== index) {
                            // Move the dragged item to the new position
                            const item = program.splice(draggedIndex, 1)[0];
                            const targetIndex = draggedIndex < index ? index - 1 : index;
                            program.splice(targetIndex, 0, item);
                            renderEditor();
                        }
                    });
                }

                return row;
            }

            function getProgramFromEditor() {
                return program.map(instr => ({
                    cmd: instr.cmd,
                    args: [...instr.args]
                }));
            }

            function loadPreset(name) {
                if (!PRESETS[name]) return;
                program = PRESETS[name].map(instr => ({
                    cmd: instr.cmd,
                    args: [...instr.args]
                }));
                renderEditor();
                if (codeMode) {
                    syncToCode();
                }
                resetTurtle();
                clearCanvas();
                drawTurtle();
            }

            // Code mode functions
            function programToText(prog, indent = 0) {
                let lines = [];
                const pad = '  '.repeat(indent);
                for (let i = 0; i < prog.length; i++) {
                    const instr = prog[i];
                    if (instr.cmd === 'repeat') {
                        lines.push(`${pad}repeat ${instr.args[0]} {`);
                        // Find matching endrepeat
                        let depth = 1;
                        let j = i + 1;
                        const block = [];
                        while (j < prog.length && depth > 0) {
                            if (prog[j].cmd === 'repeat') depth++;
                            else if (prog[j].cmd === 'endrepeat') depth--;
                            if (depth > 0) block.push(prog[j]);
                            j++;
                        }
                        lines.push(programToText(block, indent + 1));
                        lines.push(`${pad}}`);
                        i = j - 1;
                    } else if (instr.cmd === 'endrepeat') {
                        // Skip, handled by repeat
                    } else if (instr.cmd === 'set') {
                        lines.push(`${pad}set ${instr.args[0]} ${instr.args[1]}`);
                    } else if (instr.cmd === 'penUp') {
                        lines.push(`${pad}penup`);
                    } else if (instr.cmd === 'penDown') {
                        lines.push(`${pad}pendown`);
                    } else if (instr.cmd === 'setColor') {
                        lines.push(`${pad}color ${instr.args[0]}`);
                    } else if (instr.cmd === 'setWidth') {
                        lines.push(`${pad}width ${instr.args[0]}`);
                    } else if (instr.cmd === 'goto') {
                        lines.push(`${pad}goto ${instr.args[0]} ${instr.args[1]}`);
                    } else if (instr.cmd === 'home') {
                        lines.push(`${pad}home`);
                    } else {
                        lines.push(`${pad}${instr.cmd} ${instr.args.join(' ')}`);
                    }
                }
                return lines.join('\n');
            }

            // Parse argument - keep as string if it contains letters (variable/expression)
            function parseArg(s) {
                s = s.trim();
                if (/[a-zA-Z]/.test(s)) return s;  // Variable or expression
                return parseFloat(s) || 0;
            }

            function textToProgram(text) {
                const lines = text.split('\n').map(l => l.trim()).filter(l => l && !l.startsWith('//'));
                const prog = [];

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];

                    if (line === '}') {
                        prog.push({ cmd: 'endrepeat', args: [] });
                    } else if (line.startsWith('repeat ')) {
                        const match = line.match(/repeat\s+(\d+)\s*\{?/);
                        if (match) {
                            prog.push({ cmd: 'repeat', args: [parseInt(match[1])] });
                        }
                    } else if (line.startsWith('set ')) {
                        const match = line.match(/set\s+(\w+)\s+(.+)/);
                        if (match) {
                            prog.push({ cmd: 'set', args: [match[1], match[2].trim()] });
                        }
                    } else if (line.startsWith('forward ')) {
                        prog.push({ cmd: 'forward', args: [parseArg(line.slice(8))] });
                    } else if (line.startsWith('backward ')) {
                        prog.push({ cmd: 'backward', args: [parseArg(line.slice(9))] });
                    } else if (line.startsWith('left ')) {
                        prog.push({ cmd: 'left', args: [parseArg(line.slice(5))] });
                    } else if (line.startsWith('right ')) {
                        prog.push({ cmd: 'right', args: [parseArg(line.slice(6))] });
                    } else if (line === 'penup') {
                        prog.push({ cmd: 'penUp', args: [] });
                    } else if (line === 'pendown') {
                        prog.push({ cmd: 'penDown', args: [] });
                    } else if (line.startsWith('color ')) {
                        prog.push({ cmd: 'setColor', args: [line.split(' ')[1]] });
                    } else if (line.startsWith('width ')) {
                        prog.push({ cmd: 'setWidth', args: [parseArg(line.slice(6))] });
                    } else if (line.startsWith('goto ')) {
                        const parts = line.slice(5).split(/\s+/);
                        prog.push({ cmd: 'goto', args: [parseArg(parts[0]), parseArg(parts[1])] });
                    } else if (line === 'home') {
                        prog.push({ cmd: 'home', args: [] });
                    }
                }

                return prog;
            }

            function syncToCode() {
                document.getElementById('codeTextarea').value = programToText(program);
            }

            function syncFromCode() {
                program = textToProgram(document.getElementById('codeTextarea').value);
                renderEditor();
            }

            function setCodeMode(enabled) {
                codeMode = enabled;
                const commandList = document.getElementById('commandList');
                const codeEditor = document.getElementById('codeEditor');
                const addCommand = document.querySelector('.add-command');
                const blocksBtn = document.getElementById('blocksBtn');
                const codeBtn = document.getElementById('codeBtn');

                if (codeMode) {
                    syncToCode();
                    commandList.classList.add('hidden');
                    addCommand.classList.add('hidden');
                    codeEditor.classList.add('active');
                    blocksBtn.classList.remove('active');
                    codeBtn.classList.add('active');
                } else {
                    syncFromCode();
                    commandList.classList.remove('hidden');
                    addCommand.classList.remove('hidden');
                    codeEditor.classList.remove('active');
                    blocksBtn.classList.add('active');
                    codeBtn.classList.remove('active');
                }
            }

            // Controls
            document.getElementById('runBtn').addEventListener('click', () => {
                if (isRunning) {
                    isRunning = false;
                    clearTimeout(animationId);
                    document.getElementById('runBtn').textContent = 'Run';
                    updateStatus('Paused');
                } else {
                    compile();
                    resetTurtle();
                    clearCanvas();
                    isRunning = true;
                    document.getElementById('runBtn').textContent = 'Pause';
                    updateStatus('Running');
                    animate();
                }
            });

            document.getElementById('stepBtn').addEventListener('click', () => {
                if (execStack.length === 0) {
                    compile();
                    resetTurtle();
                    clearCanvas();
                }
                if (isRunning) {
                    isRunning = false;
                    clearTimeout(animationId);
                    document.getElementById('runBtn').textContent = 'Run';
                }
                executeStep();
                drawTurtle();
                updateStatus('Stepping');
            });

            document.getElementById('resetBtn').addEventListener('click', () => {
                isRunning = false;
                clearTimeout(animationId);
                document.getElementById('runBtn').textContent = 'Run';
                resetTurtle();
                clearCanvas();
                drawTurtle();
                updateStatus('Ready');
            });

            document.getElementById('clearCanvasBtn').addEventListener('click', () => {
                clearCanvas();
                drawTurtle();
            });

            document.getElementById('clearProgramBtn').addEventListener('click', () => {
                program = [];
                renderEditor();
                if (codeMode) {
                    syncToCode();
                }
            });

            // Toggle blocks/code mode
            document.getElementById('blocksBtn').addEventListener('click', () => {
                if (codeMode) setCodeMode(false);
            });

            document.getElementById('codeBtn').addEventListener('click', () => {
                if (!codeMode) setCodeMode(true);
            });

            // Add command
            document.getElementById('addCommandBtn').addEventListener('click', () => {
                const select = document.getElementById('commandSelect');
                const cmd = select.value;
                const def = COMMANDS[cmd];

                program.push({
                    cmd: cmd,
                    args: [...def.defaults]
                });

                // If repeat, also add endrepeat
                if (cmd === 'repeat') {
                    program.push({ cmd: 'endrepeat', args: [] });
                }

                renderEditor();
            });

            // Speed slider
            const speedSlider = document.getElementById('speedSlider');
            const speedDisplay = document.getElementById('speedDisplay');
            speedSlider.addEventListener('input', (e) => {
                speed = parseInt(e.target.value);
                speedDisplay.textContent = `${101 - speed}ms`;
            });

            // Preset buttons
            document.querySelectorAll('[data-preset]').forEach(btn => {
                btn.addEventListener('click', () => {
                    loadPreset(btn.dataset.preset);
                });
            });

            // Help modal
            const helpModal = document.getElementById('helpModal');
            document.getElementById('helpBtn').addEventListener('click', () => {
                helpModal.classList.add('show');
            });
            document.getElementById('closeHelp').addEventListener('click', () => {
                helpModal.classList.remove('show');
            });
            helpModal.addEventListener('click', (e) => {
                if (e.target === helpModal) helpModal.classList.remove('show');
            });

            // Fullscreen
            let isFullscreen = false;
            const fullscreenBtn = document.getElementById('fullscreenBtn');

            function toggleFullscreen() {
                isFullscreen = !isFullscreen;
                document.body.classList.toggle('fullscreen', isFullscreen);
                fullscreenBtn.title = isFullscreen ? 'Exit Fullscreen (Esc)' : 'Fullscreen (F)';
                if (!isFullscreen) {
                    setTimeout(() => {
                        initCanvas();
                        resetTurtle();
                        drawTurtle();
                    }, 50);
                }
            }

            fullscreenBtn.addEventListener('click', toggleFullscreen);

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

                switch(e.key.toLowerCase()) {
                    case ' ':
                        e.preventDefault();
                        document.getElementById('runBtn').click();
                        break;
                    case 's':
                        document.getElementById('stepBtn').click();
                        break;
                    case 'r':
                        document.getElementById('resetBtn').click();
                        break;
                    case 'c':
                        document.getElementById('clearCanvasBtn').click();
                        break;
                    case 'f':
                        toggleFullscreen();
                        break;
                    case 'escape':
                        if (isFullscreen) toggleFullscreen();
                        if (helpModal.classList.contains('show')) helpModal.classList.remove('show');
                        break;
                    case '1': loadPreset('square'); break;
                    case '2': loadPreset('spiral'); break;
                    case '3': loadPreset('star'); break;
                    case '4': loadPreset('flower'); break;
                    case '5': loadPreset('koch'); break;
                    case '6': loadPreset('rainbow'); break;
                }
            });

            // Handle resize
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    initCanvas();
                    resetTurtle();
                    drawTurtle();
                }, 250);
            });

            // Start
            initCanvas();
            loadPreset('square');
            resetTurtle();
            drawTurtle();
        </script>
    </body>
</html>
