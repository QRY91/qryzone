---
layout: false
permalink: /fun/flowfield/
---
<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="description" content="Perlin noise flow field particle simulation" />
        <title>Flow Field</title>

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="/assets/css/fun-pages.css">

        <style>
            :root {
                --accent: #00b4d8;
                --accent-rgb: 0, 180, 216;
                --accent-dim: rgba(0, 180, 216, 0.3);
                --accent-glow: rgba(0, 180, 216, 0.15);
            }

            #canvas {
                cursor: crosshair;
                touch-action: none;
            }

            .slider-control input[type="range"] { width: 80px; }
            .slider-label { min-width: 55px; }
            .slider-value { min-width: 35px; }

            .presets-label {
                font-size: 0.75rem;
                color: var(--text-secondary);
            }

            @media (max-width: 480px) {
                .slider-control input[type="range"] { width: 60px; }
            }
        </style>
    </head>
    <body>
        <a href="/fun/" class="back-link">← back</a>
        <button class="top-btn fullscreen-btn" id="fullscreenBtn" title="Fullscreen (F)">⛶</button>
        <button class="top-btn help-btn" id="helpBtn" title="Help (?)">?</button>

        <header class="game-header">
            <h1 class="game-title">Flow Field</h1>
            <div class="stats-bar">
                <div class="stat">
                    <span class="stat-label">Particles:</span>
                    <span class="stat-value" id="particleCount">2000</span>
                </div>
                <div class="stat">
                    <span class="stat-label" id="statusLabel">Running</span>
                </div>
            </div>
        </header>

        <div class="canvas-container">
            <canvas id="canvas"></canvas>
        </div>

        <div class="controls">
            <div class="control-row">
                <button class="primary" id="playPauseBtn">Pause</button>
                <button id="clearBtn">Clear</button>
                <button id="newFieldBtn">New Field</button>
            </div>
            <div class="control-row">
                <div class="slider-control">
                    <span class="slider-label">Particles:</span>
                    <input type="range" id="countSlider" min="500" max="5000" value="2000">
                    <span class="slider-value" id="countDisplay">2000</span>
                </div>
                <div class="slider-control">
                    <span class="slider-label">Scale:</span>
                    <input type="range" id="scaleSlider" min="50" max="400" value="150">
                    <span class="slider-value" id="scaleDisplay">150</span>
                </div>
                <div class="slider-control">
                    <span class="slider-label">Speed:</span>
                    <input type="range" id="speedSlider" min="1" max="10" value="3">
                </div>
            </div>
            <div class="control-row">
                <span class="presets-label">Colors:</span>
                <button data-color="ocean" class="active">Ocean</button>
                <button data-color="fire">Fire</button>
                <button data-color="rainbow">Rainbow</button>
                <button data-color="mono">Mono</button>
                <button data-color="neon">Neon</button>
            </div>
            <div class="control-row">
                <div class="slider-control">
                    <span class="slider-label">Fade:</span>
                    <input type="range" id="fadeSlider" min="1" max="30" value="5">
                </div>
                <div class="slider-control">
                    <span class="slider-label">Evolve:</span>
                    <input type="range" id="evolveSlider" min="0" max="20" value="2">
                </div>
            </div>
        </div>

        <!-- Help Modal -->
        <div class="modal-overlay" id="helpModal">
            <div class="modal">
                <h2>Flow Field</h2>
                <p>Thousands of particles flow through an invisible vector field generated by <a href="https://en.wikipedia.org/wiki/Perlin_noise" target="_blank" style="color: var(--accent)">Perlin noise</a>.</p>
                <p><strong>Interactions:</strong></p>
                <ul>
                    <li><strong>Mouse/Touch</strong> - Create disturbance ripples</li>
                    <li><strong>New Field</strong> - Generate a new noise pattern</li>
                </ul>
                <p><strong>Controls:</strong></p>
                <ul>
                    <li><strong>Particles</strong> - Number of flowing particles</li>
                    <li><strong>Scale</strong> - Noise scale (smaller = more chaotic)</li>
                    <li><strong>Speed</strong> - Particle velocity</li>
                    <li><strong>Fade</strong> - Trail fade rate</li>
                    <li><strong>Evolve</strong> - How fast the field changes over time</li>
                </ul>
                <p><strong>Keyboard:</strong></p>
                <ul>
                    <li><strong>Space</strong> - Play/Pause</li>
                    <li><strong>C</strong> - Clear trails</li>
                    <li><strong>N</strong> - New field</li>
                    <li><strong>F</strong> - Fullscreen</li>
                </ul>
                <button class="modal-close" id="closeHelp">Got it</button>
            </div>
        </div>

        <script>
            // Perlin Noise implementation
            class PerlinNoise {
                constructor() {
                    this.p = [];
                    for (let i = 0; i < 256; i++) this.p[i] = i;
                    for (let i = 255; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [this.p[i], this.p[j]] = [this.p[j], this.p[i]];
                    }
                    this.p = this.p.concat(this.p);
                }

                fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
                lerp(a, b, t) { return a + t * (b - a); }
                grad(hash, x, y, z) {
                    const h = hash & 15;
                    const u = h < 8 ? x : y;
                    const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
                    return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
                }

                noise(x, y, z = 0) {
                    const X = Math.floor(x) & 255;
                    const Y = Math.floor(y) & 255;
                    const Z = Math.floor(z) & 255;
                    x -= Math.floor(x);
                    y -= Math.floor(y);
                    z -= Math.floor(z);
                    const u = this.fade(x);
                    const v = this.fade(y);
                    const w = this.fade(z);
                    const A = this.p[X] + Y, AA = this.p[A] + Z, AB = this.p[A + 1] + Z;
                    const B = this.p[X + 1] + Y, BA = this.p[B] + Z, BB = this.p[B + 1] + Z;

                    return this.lerp(
                        this.lerp(
                            this.lerp(this.grad(this.p[AA], x, y, z), this.grad(this.p[BA], x - 1, y, z), u),
                            this.lerp(this.grad(this.p[AB], x, y - 1, z), this.grad(this.p[BB], x - 1, y - 1, z), u),
                            v
                        ),
                        this.lerp(
                            this.lerp(this.grad(this.p[AA + 1], x, y, z - 1), this.grad(this.p[BA + 1], x - 1, y, z - 1), u),
                            this.lerp(this.grad(this.p[AB + 1], x, y - 1, z - 1), this.grad(this.p[BB + 1], x - 1, y - 1, z - 1), u),
                            v
                        ),
                        w
                    );
                }
            }

            // State
            let noise = new PerlinNoise();
            let particles = [];
            let running = true;
            let particleCount = 2000;
            let noiseScale = 150;
            let speed = 3;
            let fadeRate = 5;
            let evolveRate = 2;
            let colorMode = 'ocean';
            let zOffset = 0;
            let mousePos = null;

            // Canvas
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');

            // Color modes
            const COLORS = {
                ocean: (angle) => `hsla(${180 + angle * 30}, 80%, 55%, 0.5)`,
                fire: (angle) => `hsla(${angle * 30}, 100%, 50%, 0.5)`,
                rainbow: (angle) => `hsla(${angle * 60}, 80%, 55%, 0.5)`,
                mono: (angle) => `rgba(0, 180, 216, 0.4)`,
                neon: (angle) => `hsla(${280 + angle * 40}, 100%, 60%, 0.5)`
            };

            // Particle class
            class Particle {
                constructor() {
                    this.reset();
                }

                reset() {
                    this.x = Math.random() * canvas.width;
                    this.y = Math.random() * canvas.height;
                    this.prevX = this.x;
                    this.prevY = this.y;
                    this.life = Math.random() * 100 + 50;
                }

                update() {
                    this.prevX = this.x;
                    this.prevY = this.y;

                    // Get flow angle from noise
                    let angle = noise.noise(this.x / noiseScale, this.y / noiseScale, zOffset) * Math.PI * 4;

                    // Mouse influence
                    if (mousePos) {
                        const dx = this.x - mousePos.x;
                        const dy = this.y - mousePos.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 100) {
                            const force = (100 - dist) / 100;
                            angle += Math.atan2(dy, dx) * force * 2;
                        }
                    }

                    this.x += Math.cos(angle) * speed;
                    this.y += Math.sin(angle) * speed;
                    this.life--;

                    // Wrap around edges - track if wrapped to avoid drawing line across canvas
                    this.wrapped = false;
                    if (this.x < 0) { this.x = canvas.width; this.wrapped = true; }
                    if (this.x > canvas.width) { this.x = 0; this.wrapped = true; }
                    if (this.y < 0) { this.y = canvas.height; this.wrapped = true; }
                    if (this.y > canvas.height) { this.y = 0; this.wrapped = true; }

                    if (this.life <= 0) this.reset();

                    return angle;
                }

                draw(angle) {
                    // Skip drawing if particle wrapped around edge
                    if (this.wrapped) return;

                    ctx.beginPath();
                    ctx.moveTo(this.prevX, this.prevY);
                    ctx.lineTo(this.x, this.y);
                    ctx.strokeStyle = COLORS[colorMode](angle);
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }

            // Initialize
            function init() {
                const container = document.querySelector('.canvas-container');
                const maxWidth = container.clientWidth - 20;
                const maxHeight = container.clientHeight - 20;
                const size = Math.min(maxWidth, maxHeight, 700);

                canvas.width = size;
                canvas.height = size;

                createParticles();
                clear();
            }

            function createParticles() {
                particles = [];
                for (let i = 0; i < particleCount; i++) {
                    particles.push(new Particle());
                }
                document.getElementById('particleCount').textContent = particleCount;
            }

            function clear() {
                ctx.fillStyle = '#0a0a0f';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            function newField() {
                noise = new PerlinNoise();
                zOffset = 0;
                clear();
            }

            // Animation loop
            function animate() {
                if (running) {
                    // Fade effect
                    ctx.fillStyle = `rgba(10, 10, 15, ${fadeRate / 100})`;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Update and draw particles
                    particles.forEach(p => {
                        const angle = p.update();
                        p.draw(angle);
                    });

                    // Evolve the field over time
                    zOffset += evolveRate * 0.0005;
                }
                requestAnimationFrame(animate);
            }

            // Mouse interaction
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                mousePos = {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            });

            canvas.addEventListener('mouseleave', () => {
                mousePos = null;
            });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                mousePos = {
                    x: e.touches[0].clientX - rect.left,
                    y: e.touches[0].clientY - rect.top
                };
            });

            canvas.addEventListener('touchend', () => {
                mousePos = null;
            });

            // Controls
            const playPauseBtn = document.getElementById('playPauseBtn');
            playPauseBtn.addEventListener('click', () => {
                running = !running;
                playPauseBtn.textContent = running ? 'Pause' : 'Play';
                document.getElementById('statusLabel').textContent = running ? 'Running' : 'Paused';
            });

            document.getElementById('clearBtn').addEventListener('click', clear);
            document.getElementById('newFieldBtn').addEventListener('click', newField);

            // Sliders
            const countSlider = document.getElementById('countSlider');
            const countDisplay = document.getElementById('countDisplay');
            countSlider.addEventListener('input', (e) => {
                particleCount = parseInt(e.target.value);
                countDisplay.textContent = particleCount;
                createParticles();
            });

            const scaleSlider = document.getElementById('scaleSlider');
            const scaleDisplay = document.getElementById('scaleDisplay');
            scaleSlider.addEventListener('input', (e) => {
                noiseScale = parseInt(e.target.value);
                scaleDisplay.textContent = noiseScale;
            });

            document.getElementById('speedSlider').addEventListener('input', (e) => {
                speed = parseInt(e.target.value);
            });

            document.getElementById('fadeSlider').addEventListener('input', (e) => {
                fadeRate = parseInt(e.target.value);
            });

            document.getElementById('evolveSlider').addEventListener('input', (e) => {
                evolveRate = parseInt(e.target.value);
            });

            // Color buttons
            document.querySelectorAll('[data-color]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('[data-color]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    colorMode = btn.dataset.color;
                });
            });

            // Help modal
            const helpModal = document.getElementById('helpModal');
            document.getElementById('helpBtn').addEventListener('click', () => {
                helpModal.classList.add('show');
            });
            document.getElementById('closeHelp').addEventListener('click', () => {
                helpModal.classList.remove('show');
            });
            helpModal.addEventListener('click', (e) => {
                if (e.target === helpModal) helpModal.classList.remove('show');
            });

            // Fullscreen
            let isFullscreen = false;
            const fullscreenBtn = document.getElementById('fullscreenBtn');

            function toggleFullscreen() {
                isFullscreen = !isFullscreen;
                document.body.classList.toggle('fullscreen', isFullscreen);
                fullscreenBtn.title = isFullscreen ? 'Exit Fullscreen (Esc)' : 'Fullscreen (F)';
                setTimeout(init, 50);
            }

            fullscreenBtn.addEventListener('click', toggleFullscreen);

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT') return;

                switch(e.key.toLowerCase()) {
                    case 'f':
                        toggleFullscreen();
                        break;
                    case 'escape':
                        if (isFullscreen) toggleFullscreen();
                        if (helpModal.classList.contains('show')) helpModal.classList.remove('show');
                        break;
                    case ' ':
                        e.preventDefault();
                        running = !running;
                        playPauseBtn.textContent = running ? 'Pause' : 'Play';
                        document.getElementById('statusLabel').textContent = running ? 'Running' : 'Paused';
                        break;
                    case 'c':
                        clear();
                        break;
                    case 'n':
                        newField();
                        break;
                }
            });

            // Resize
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(init, 250);
            });

            // Start
            init();
            requestAnimationFrame(animate);
        </script>
    </body>
</html>
